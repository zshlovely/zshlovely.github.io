
<!DOCTYPE html>
<html lang="zh-CN">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Java基础," />
  

  
    <meta name="description" content="既然选择远方，便只顾风雨兼程" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>Java 高并发 [ shaohua&#39;s blog ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="/images/logo.png">
    <span class="title">shaohua&#39;s blog</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/search" class="pure-menu-link">搜索</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        Java 高并发
      </h1>
      <span>
        
        <time class="time" datetime="2021-02-11T17:10:20.000Z">
        2021-02-12
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>
      </span>
    </span>
      <span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>
      <span class="read">阅读耗时 314 分钟</span>
    </header>

    <div class="post-content">
      <h1 id="1-java-高并发基础篇"><a href="#1-java-高并发基础篇" class="headerlink" title="1. java 高并发基础篇"></a>1. java 高并发基础篇</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="1-同步（Synchronous）和异步（Asynchronous）"><a href="#1-同步（Synchronous）和异步（Asynchronous）" class="headerlink" title="1. 同步（Synchronous）和异步（Asynchronous）"></a>1. <strong>同步（Synchronous）和异步（Asynchronous）</strong></h3><p>同步和异步通常来形容一次方法调用。</p>
<p><code>同步方法</code>: <strong>调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为</strong>。</p>
<p>异步方法&#96;: <strong>调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作</strong>。异步方法通常会在另外一个线程中“真实”地执行。整个过程，不会阻碍调用者的工作。</p>
<p><img src="/../../../../images/sync-async.png" alt="1654309906578"></p>
<h3 id="2-并发（Concurrency）和并行（Parallelism）"><a href="#2-并发（Concurrency）和并行（Parallelism）" class="headerlink" title="2. 并发（Concurrency）和并行（Parallelism）"></a>2. <strong>并发（Concurrency）和并行（Parallelism）</strong></h3><p><code>并发</code>偏重于多个任务<strong>交替</strong>执行，而多个任务之间有可能还是串行的。<strong>并发</strong>说的是在<strong>一个时间段内</strong>，多件事情在这个时间段内<strong>交替执行</strong>。</p>
<p><code>并行</code>是真正意义上的“同时执行。<strong>并行</strong>说的是多件事情在<strong>同一个时刻</strong>同事发生。</p>
<h3 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3. 临界区"></a>3. <strong>临界区</strong></h3><p>临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用，但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</p>
<h3 id="4-阻塞（Blocking）和非阻塞（Non-Blocking）"><a href="#4-阻塞（Blocking）和非阻塞（Non-Blocking）" class="headerlink" title="4. 阻塞（Blocking）和非阻塞（Non-Blocking）"></a>4. <strong>阻塞（Blocking）和非阻塞（Non-Blocking）</strong></h3><p>阻塞和非阻塞通常用来形容很多线程间的相互影响。</p>
<p>比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待。等待会导致线程挂起，这种情况就是<strong>阻塞</strong>。</p>
<p><strong>非阻塞</strong>与之相反，它强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断向前执行。</p>
<h3 id="5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><a href="#5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）" class="headerlink" title="5. 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"></a>5. <strong>死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</strong></h3><p><strong>死锁</strong>、<strong>饥饿</strong>和<strong>活锁</strong>都属于多线程的活跃性问题。</p>
<p><strong>死锁</strong>应该是最糟糕的一种情况。</p>
<p><strong>饥饿</strong>是指某一个或者多个线程因为种种原因无法获得所要的资源，导致一直无法执行。比如它的优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。</p>
<p><strong>活锁</strong>是一种非常有趣的情况。这么一种场景，当你要做电梯下楼时，电梯到了，门开了，这是你正准备出去。但很不巧的是，门外一个人当着你的去路，他想进来。于是，你很礼貌地靠左走，礼让对方。同时，对方也非常礼貌的靠右走，希望礼让你。结果，你们俩就又撞上了。于是乎，你们都意识到了问题，希望尽快避让对方，你立即向右边走，同时，他立即向左边走。结果，又撞上了！如果线程智力不够。且都秉承着“谦让”的原则，主动将资源释放给他人使用，那么久会导致资源不断地在两个线程间跳动，而没有一个线程可以同时拿到所有资源正常执行。这种情况就是活锁。</p>
<h4 id="1-死锁举例"><a href="#1-死锁举例" class="headerlink" title="1. 死锁举例"></a>1. 死锁举例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.jvm.visualvm;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Obj1 obj1 = new Obj1();</span><br><span class="line">        Obj2 obj2 = new Obj2();</span><br><span class="line">        Thread thread1 = new Thread(new SynAddRunalbe(obj1, obj2, 1, 2, true));</span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread thread2 = new Thread(new SynAddRunalbe(obj1, obj2, 2, 1, false));</span><br><span class="line">        thread2.setName(&quot;thread2&quot;);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 线程死锁等待演示</span><br><span class="line">     */</span><br><span class="line">    public static class SynAddRunalbe implements Runnable &#123;</span><br><span class="line">        Obj1 obj1;</span><br><span class="line">        Obj2 obj2;</span><br><span class="line">        int a, b;</span><br><span class="line">        boolean flag;</span><br><span class="line"></span><br><span class="line">        public SynAddRunalbe(Obj1 obj1, Obj2 obj2, int a, int b, boolean flag) &#123;</span><br><span class="line">            this.obj1 = obj1;</span><br><span class="line">            this.obj2 = obj2;</span><br><span class="line">            this.a = a;</span><br><span class="line">            this.b = b;</span><br><span class="line">            this.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (flag) &#123;</span><br><span class="line">                    synchronized (obj1) &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                        synchronized (obj2) &#123;</span><br><span class="line">                            System.out.println(a + b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    synchronized (obj2) &#123;</span><br><span class="line">                        Thread.sleep(100);</span><br><span class="line">                        synchronized (obj1) &#123;</span><br><span class="line">                            System.out.println(a + b);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static class Obj1 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Obj2 &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行上面代码，可以通过jstack查看到死锁信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jps 获取到 pid</span><br><span class="line">jstack pid 查看jstack</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;thread2&quot;:</span><br><span class="line">	at com.shlly.learn.test.Demo$SynAddRunalbe.run(Demo.java:46)</span><br><span class="line">	- waiting to lock &lt;0x0000000715692ed8&gt; (a com.shlly.learn.test.Demo$Obj1)</span><br><span class="line">	- locked &lt;0x0000000715695958&gt; (a com.shlly.learn.test.Demo$Obj2)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">&quot;thread1&quot;:</span><br><span class="line">	at com.shlly.learn.test.Demo$SynAddRunalbe.run(Demo.java:39)</span><br><span class="line">	- waiting to lock &lt;0x0000000715695958&gt; (a com.shlly.learn.test.Demo$Obj2)</span><br><span class="line">	- locked &lt;0x0000000715692ed8&gt; (a com.shlly.learn.test.Demo$Obj1)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>

<p>thread1持有com.jvm.visualvm.Demo$Obj1的锁，等待获取com.jvm.visualvm.Demo$Obj2的锁 ,</p>
<p>thread2持有com.jvm.visualvm.Demo$Obj2的锁，等待获取com.jvm.visualvm.Demo$Obj1的锁 ,</p>
<p>两个线程相互等待获取对方持有的锁，出现死锁。</p>
<h4 id="2-饥饿举例"><a href="#2-饥饿举例" class="headerlink" title="2. 饥饿举例"></a>2. 饥饿举例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm.jconsole;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class ExecutorLock &#123;</span><br><span class="line">    private static ExecutorService single= Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    public static class AnotherCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;in AnotherCallable&quot;);</span><br><span class="line">            return &quot;annother success&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            System.out.println(&quot;in MyCallable&quot;);</span><br><span class="line">            Future&lt;String&gt; submit = single.submit(new AnotherCallable());</span><br><span class="line">            return &quot;success:&quot; + submit.get();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">            MyCallable task = new MyCallable();</span><br><span class="line">            Future&lt;String&gt; submit = single.submit(task);</span><br><span class="line">            System.out.println(submit.get());</span><br><span class="line">            System.out.println(&quot;over&quot;);</span><br><span class="line">            single.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in MyCallable</span><br></pre></td></tr></table></figure>

<p>使用jstack命令查看线程堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps 获取到 pid</span><br><span class="line">jstack pid 查看jstack</span><br></pre></td></tr></table></figure>

<p>堆栈信息结合图中的代码，可以看出主线程在32行处于等待中，线程池中的工作线程在25行处于等待中，等待获取结果。由于线程池是一个线程，AnotherCallable得不到执行，而被饿死，最终导致了程序死锁的现象。</p>
<h2 id="2-并发级别"><a href="#2-并发级别" class="headerlink" title="2. 并发级别"></a>2. 并发级别</h2><p>由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别分为 <strong>阻塞</strong>、<strong>无饥饿</strong>、<strong>无障碍</strong>、<strong>无锁</strong>、<strong>无等待</strong>几种。</p>
<h3 id="1-阻塞"><a href="#1-阻塞" class="headerlink" title="1. 阻塞"></a>1. 阻塞</h3><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。即<strong>悲观</strong></p>
<p>当我们使用synchronized关键字或者重入锁时，我们得到的就是阻塞的线程。</p>
<p>synchronize关键字和重入锁都试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。</p>
<h3 id="2-无饥饿-Starvation-Free"><a href="#2-无饥饿-Starvation-Free" class="headerlink" title="2. 无饥饿(Starvation-Free)"></a>2. <strong>无饥饿(Starvation-Free)</strong></h3><p>如果线程之间是有优先级的，那么线程调度的时候总是会倾向于先满足高优先级的线程。</p>
<p>对于非公平锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。</p>
<h3 id="3-无障碍-Obstruction-Free"><a href="#3-无障碍-Obstruction-Free" class="headerlink" title="3. 无障碍(Obstruction-Free)"></a>3. <strong>无障碍(Obstruction-Free)</strong></h3><p>无障碍是一种最弱的非阻塞调度。即<strong>乐观</strong></p>
<p>两个线程如果无障碍地执行，那么不会因为临界区的问题导致一方被挂起。</p>
<p>对于无障碍的线程来说，一旦检测到大家一起修改共享数据，把数据改坏了，它就会立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。</p>
<p>无障碍的多线程程序并不一定能顺畅运行。因为当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。所以，我们可能会非常希望在这一堆线程中，至少可以有一个线程能够在有限的时间内完成自己的操作，而退出临界区。</p>
<p>一种可行的无障碍实现可以依赖一个”一致性标记”来实现。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。</p>
<p>数据库中乐观锁，应该比较熟悉，表中需要一个字段version(版本号)，每次更新数据version+1，更新的时候将版本号作为条件进行更新，根据更新影响的行数判断更新是否成功。</p>
<p>伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.查询数据，此时版本号为w_v</span><br><span class="line">2.打开事务</span><br><span class="line">3.做一些业务操作</span><br><span class="line">4.update t set version = version+1 where id = 记录id and version = w_v;//此行会返回影响的行数c</span><br><span class="line">5.if(c&gt;0)&#123;        </span><br><span class="line">//提交事务</span><br><span class="line">&#125;else&#123; </span><br><span class="line">//回滚事务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-无锁-Lock-Free"><a href="#4-无锁-Lock-Free" class="headerlink" title="4. 无锁(Lock-Free)"></a>4. <strong>无锁(Lock-Free)</strong></h3><p>无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发<strong>保证必然有一个线程能够在有限步内完成操作离开临界区</strong>。</p>
<h3 id="5-无等待"><a href="#5-无等待" class="headerlink" title="5. 无等待"></a>5. <strong>无等待</strong></h3><p>无锁只要求有一个线程可以在有限步内完成操作， 而无等待则在无锁的基础上更进一步扩展。它要求<strong>所有线程都必须在有限步内完成</strong>，这样不会引起饥饿问题。</p>
<p>一种典型的无等待结果就是RCU(Read Copy Update)。基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先获取原始数据的副本，接着只修改副本数据(这就是为什么读可以不加控制)，修改完成后，在合适的时机回写数据。</p>
<h2 id="3-有关并行的两个重要定律"><a href="#3-有关并行的两个重要定律" class="headerlink" title="3. 有关并行的两个重要定律"></a>3. 有关并行的两个重要定律</h2><h3 id="1-Amdahl-阿姆达尔-定律"><a href="#1-Amdahl-阿姆达尔-定律" class="headerlink" title="1. Amdahl(阿姆达尔)定律"></a>1. <strong>Amdahl(阿姆达尔)定律</strong></h3><p> 略</p>
<h3 id="2-Gustafson定律"><a href="#2-Gustafson定律" class="headerlink" title="2. Gustafson定律"></a>2. <strong>Gustafson定律</strong></h3><p>略</p>
<h2 id="4-JMM相关的一些概念"><a href="#4-JMM相关的一些概念" class="headerlink" title="4. JMM相关的一些概念"></a>4. JMM相关的一些概念</h2><p>JMM (Java Memory Model)： java内存模型</p>
<p>由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序中数据访问<strong>一致性</strong>和<strong>安全性</strong>将会受到严重挑战。JMM关键技术点都是围绕着多线程的<strong>原子性、可见性、有序性</strong>来建立的。</p>
<h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>原子性是指<strong>操作是不可分的</strong>，要么全部一起执行，要么不执行。</p>
<p>在java中，其表现在对于共享变量的某些操作，是不可分的，必须连续的完成。比如a++，对于共享变量a的操作，实际上会执行3个步骤：</p>
<ol>
<li>读取变量a的值，假如a&#x3D;1</li>
<li>a的值+1，为2 </li>
<li>将2值赋值给变量a，此时a的值应该为2</li>
</ol>
<p>这三个操作中任意一个操作，a的值如果被其他线程篡改了，那么都会出现我们不希望出现的结果。</p>
<p>所以必须保证这3个操作是原子性的。</p>
<p>java中实现原子操作的方法大致有2种：<strong>锁机制</strong>、<strong>无锁CAS机制</strong>，后面的章节中会有介绍。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2. 可见性"></a>2. 可见性</h3><p><strong>可见性是值一个线程对共享变量的修改，对于另一个线程来说是否是可以看到的。</strong></p>
<p>我们先看一下java线程内存模型：</p>
<p><img src="/../../../../images/java-thread-jmm.jpg" alt="java thread jmm"></p>
<ul>
<li>我们定义的所有变量都储存在 <code>主内存</code>中</li>
<li>每个线程都有自己 <code>独立的工作内存</code>，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</li>
<li>线程对共享变量所有的操作都必须在自己的工作内存中进行，不能直接从主内存中读写（不能越级）</li>
<li>不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行。（同级不能相互访问）</li>
</ul>
<p>线程需要修改一个共享变量X，需要先把X从主内存复制一份到线程的工作内存，在自己的工作内存中修改完毕之后，再从工作内存中回写到主内存。如果线程对变量的操作没有刷写回主内存的话，仅仅改变了自己的工作内存的变量的副本，那么<strong>对于其他线程来说是不可见的</strong>。</p>
<p><strong>共享变量可见性的实现原理：</strong></p>
<p>线程A对共享变量的修改要被线程B及时看到的话，需要进过以下步骤：</p>
<ol>
<li><p>线程A在自己的工作内存中修改变量之后，需要将变量的值刷新到主内存中 </p>
</li>
<li><p>线程B要把主内存中变量的值更新到工作内存中</p>
</li>
</ol>
<p>关于线程可见性的控制，可以使用<strong>volatile</strong>、<strong>synchronized</strong>、<strong>锁</strong>来实现，后面会有详细介绍。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3. 有序性"></a>3. 有序性</h3><p>有序性指的是程序按照代码的先后顺序执行。</p>
<p>为了性能优化，编译器和处理器会进行指令冲排序，有时候会改变程序语句的先后顺序，比如程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 20;</span><br><span class="line">int c = a+b;</span><br></pre></td></tr></table></figure>

<p>编译器优化后可能变成:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int b = 20;</span><br><span class="line">int a = 1;</span><br><span class="line">int c = a+b;</span><br></pre></td></tr></table></figure>

<p>这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。</p>
<p>我们再举个 在单例模式的实现上有一种双重检验锁定的方式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    static Singleton instance;</span><br><span class="line"></span><br><span class="line">    static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看 <code>instance=newSingleton();</code></p>
<p><strong>未被编译器优化的操作：</strong></p>
<ol>
<li>指令1：分配一块内存 M</li>
<li>指令2：在内存M上初始化Singleton对象</li>
<li>指令3：将M的地址赋值给instance变量</li>
</ol>
<p><strong>编译器优化后的操作指令：</strong></p>
<ol>
<li>指令1：分配一块内存S</li>
<li>指令2：将M的地址赋值给instance变量</li>
<li>指令3：在内存M上初始化Singleton对象</li>
</ol>
<p>现在有2个线程，刚好执行的代码被编译器优化过，过程如下：</p>
<p><img src="/../../../../images/jmm-thread-singleton.png" alt="jmm-thread-singleton"></p>
<p>最终线程B获取的instance是没有初始化的，此时去使用instance可能会产生一些意想不到的错误。</p>
<p>现在比较好的做法就是采用静态内部内的方式实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private SingletonDemo() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonDemo getInstance() &#123;</span><br><span class="line">        return SingletonDemoHandler.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonDemoHandler &#123;</span><br><span class="line">        private static final SingletonDemo instance = new SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-深入理解进程和线程"><a href="#5-深入理解进程和线程" class="headerlink" title="5. 深入理解进程和线程"></a>5. 深入理解进程和线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p>
<p><strong>进程具有的特征：</strong></p>
<ul>
<li><strong>动态性</strong>：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的</li>
<li><strong>并发性</strong>：任何进程都可以同其他进行一起并发执行</li>
<li><strong>独立性</strong>：进程是系统进行资源分配和调度的一个独立单位</li>
<li><strong>结构性</strong>：进程由程序，数据和进程控制块三部分组成</li>
</ul>
<p>我们经常使用windows系统，经常会看见.exe后缀的文件，双击这个.exe文件的时候，这个文件中的指令就会被系统加载，那么我们就能得到一个关于这个.exe程序的进程。进程是<strong>“活”</strong>的，是<strong>程序的一次运行</strong>。</p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>线程是轻量级的进程，是程序调度的最小单元。使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</p>
<p>线程的所有状态在<strong>java.lang.Thread中的State</strong>枚举中有定义，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">    NEW, </span><br><span class="line">    RUNNABLE, </span><br><span class="line">    BLOCKED, </span><br><span class="line">    WAITING, </span><br><span class="line">    TIMED_WAITING, </span><br><span class="line">    TERMINATED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程几个状态的介绍：</p>
<ul>
<li><strong>New</strong>：表示刚刚创建的线程，这种线程还没有开始执行</li>
<li><strong>RUNNABLE</strong>：运行状态，线程的start()方法调用后，线程会处于这种状态</li>
<li><strong>BLOCKED</strong>：阻塞状态。当线程在执行的过程中遇到了synchronized同步块，但这个同步块被其他线程已获取还未释放时，当前线程将进入阻塞状态，会暂停执行，直到获取到锁。当线程获取到锁之后，又会进入到运行状态（RUNNABLE）</li>
<li><strong>WAITING</strong>：等待状态。和TIMEWAITING都表示等待状态，区别是WAITING会进入一个无时间限制的等，而TIMEWAITING会进入一个有限的时间等待，那么等待的线程究竟在等什么呢？一般来说，WAITING的线程正式在等待一些特殊的事件，比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到期望的事件，线程就会再次进入RUNNABLE运行状态。</li>
<li><strong>TERMINATED</strong>：表示结束状态，线程执行完毕之后进入结束状态。</li>
</ul>
<p><strong>注意：从NEW状态出发后，线程不能在回到NEW状态，同理，处理TERMINATED状态的线程也不能在回到RUNNABLE状态</strong></p>
<h2 id="6-线程的基本操作"><a href="#6-线程的基本操作" class="headerlink" title="6. 线程的基本操作"></a>6. 线程的基本操作</h2><h3 id="1-新建线程"><a href="#1-新建线程" class="headerlink" title="1. 新建线程"></a>1. 新建线程</h3><p>新建线程只需要使用new关键字创建一个线程对象，然后调用它的start()启动线程即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = new Thread();</span><br><span class="line">thread1.start();</span><br></pre></td></tr></table></figure>

<p>线程start()之后，会干什么呢？</p>
<p>线程有个run()方法，start()会创建一个新的线程并让这个线程执行run()方法。</p>
<p>这里需要注意&#96;，下面代码也能通过编译，也能正常执行。但是，却不能新建一个线程，而是在当前线程中调用run()方法，将run方法只是作为一个普通的方法调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = new Thread();</span><br><span class="line">thread1.run();</span><br></pre></td></tr></table></figure>

<p>希望大家注意，调用start方法和直接调用run方法的区别:</p>
<p><strong>start方法是启动一个线程，run方法只会在当前线程中串行的执行run方法中的代码。</strong></p>
<p>默认情况下， 线程的run方法什么都没有，启动一个线程之后马上就结束了，所以如果你需要线程做点什么，需要把您的代码写到run方法中，所以必须重写run方法。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;hello,我是一个线程!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">thread1.start()</span><br></pre></td></tr></table></figure>

<p>上面是使用匿名内部类实现的，重写了Thread的run方法，并且打印了一条信息。</p>
<p><strong>我们可以通过继承Thread类，然后重写run方法，来自定义一个线程。</strong></p>
<p>但考虑<strong>java是单继承的</strong>，从扩展性上来说，我们实现一个接口来自定义一个线程更好一些，java中刚好提供了<strong>Runnable接口</strong>来自定义一个线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterfacepublic</span><br><span class="line">interface Runnable &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread类有一个非常重要的构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Thread(Runnable target) </span><br></pre></td></tr></table></figure>

<p>我们在看一下Thread的run方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当我们启动线程的start方法之后，线程会执行run方法，run方法中会调用Thread构造方法传入的target的run方法。</p>
<p><strong>实现Runnable接口是比较常见的做法，也是推荐的做法。</strong>!!!</p>
<h3 id="2-终止线程"><a href="#2-终止线程" class="headerlink" title="2. 终止线程"></a>2. <strong>终止线程</strong></h3><p>一般来说线程执行完毕就会结束，无需手动关闭。</p>
<p>如果我们想关闭一个正在运行的线程，有什么方法呢？可以看一下Thread类中提供了一个stop()方法，调用这个方法，就可以立即将一个线程终止，非常方便。</p>
<p>我们使用idea或者eclipse的时候，会发现这个方法是一个废弃的方法，也就是说，在将来，jdk可能就会移除该方法。</p>
<p>stop方法为何会被废弃而不推荐使用？stop方法过于暴力，强制把正在执行的方法停止了。这里就比较推荐<strong>线程中断</strong>了。</p>
<h3 id="3-线程中断"><a href="#3-线程中断" class="headerlink" title="3. 线程中断"></a>3. 线程中断</h3><p>在java中，线程中断是一种重要的线程协作机制。</p>
<p>在上面中，我们已经详细讨论了stop方法停止线程的坏处，jdk中提供了更好的中断线程的方法。严格的说，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出了！至于目标线程接收到通知之后如何处理，则完全由目标线程自己决定，这点很重要，如果中断后，线程立即无条件退出，我们又会到stop方法的老问题。</p>
<p>Thread提供了3个与线程中断有关的方法，这3个方法容易混淆，注意下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void interrupt() //中断线程</span><br><span class="line">public boolean isInterrupted() //判断线程是否被中断</span><br><span class="line">public static boolean interrupted()  //判断线程是否被中断，并清除当前中断状态</span><br></pre></td></tr></table></figure>

<p><strong>interrupt()<strong>方法是一个</strong>实例方法</strong>，它通知目标线程中断，也就是设置中断标志位为true，中断标志位表示当前线程已经被中断了。</p>
<p><strong>isInterrupted()<strong>方法也是一个</strong>实例方法</strong>，它判断当前线程是否被中断（通过检查中断标志位）。</p>
<p><strong>interrupted()<strong>是一个</strong>静态方法</strong>，返回boolean类型，也是用来判断当前线程是否被中断，但是同时会清除当前线程的中断标志位的状态。</p>
<h4 id="1-一个便于理解的例子"><a href="#1-一个便于理解的例子" class="headerlink" title="1. 一个便于理解的例子"></a>1. 一个便于理解的例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">class test &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (this.isInterrupted()) &#123;</span><br><span class="line">                        System.out.println(&quot;我要退出了!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中有个死循环，interrupt()方法被调用之后，线程的中断标志将被置为true，循环体中通过检查线程的中断标志是否为ture（ <code>this.isInterrupted()</code>）来判断线程是否需要退出了。</p>
<p>再看一种中断的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    static volatile boolean isStop = false;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (isStop) &#123;</span><br><span class="line">                        System.out.println(&quot;我要退出了!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        isStop = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中通过一个变量isStop来控制线程是否停止。</p>
<p>通过变量控制和线程自带的interrupt方法来中断线程有什么区别？</p>
<p>如果一个线程调用了sleep方法，一直处于休眠状态，通过变量控制，还可以中断线程么？</p>
<p>此时只能使用线程提供的interrupt方法来中断线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //休眠100秒</span><br><span class="line">                    try&#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(100);</span><br><span class="line">                    &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;我要退出了!&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用interrupt()方法之后，线程的sleep方法将会抛出 <code>InterruptedException</code>异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //休眠100秒</span><br><span class="line">                    try&#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(100);</span><br><span class="line">                    &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(this.isInterrupted())&#123;</span><br><span class="line">                        System.out.println(&quot;我要退出了!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，发现程序无法终止。为什么？</p>
<p>代码需要改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread thread1 = new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    //休眠100秒</span><br><span class="line">                    try&#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(100);</span><br><span class="line">                    &#125;catch (InterruptedException e)&#123;</span><br><span class="line">                        this.interrupt();</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(this.isInterrupted())&#123;</span><br><span class="line">                        System.out.println(&quot;我要退出了!&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread1.setName(&quot;thread1&quot;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意：sleep方法由于中断而抛出异常之后，线程的中断标志会被清除（置为false），所以在异常中需要执行this.interrupt()方法，将中断标志位置为true</strong>。</p>
<h3 id="4-等待（wait）和通知（notify）"><a href="#4-等待（wait）和通知（notify）" class="headerlink" title="4. 等待（wait）和通知（notify）"></a>4. <strong>等待（wait）和通知（notify）</strong></h3><p>为了支持多线程之间的协作，JDK提供了两个非常重要的方法：等待wait()方法和通知notify()方法。</p>
<p>这2个方法并不是在Thread类中的，而是在Object类中定义的。这意味着所有的对象都可以调用者两个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException;</span><br><span class="line">public final native void notify();</span><br></pre></td></tr></table></figure>

<p>当在一个对象实例上调用wait()方法后，当前线程就会在这个对象上等待。</p>
<p>比如在线程A中，调用了obj.wait()方法，那么线程A就会停止继续执行，转为等待状态。等待到什么时候结束呢？线程A会一直等到其他线程调用obj.notify()方法为止，这时，obj对象成为了多个线程之间的有效通信手段。</p>
<p>那么wait()方法和notify()方法是如何工作的呢？</p>
<p>如果一个线程调用了object.wait()方法，那么它就会进出object对象的等待队列。这个队列中，可能会有多个线程，因为系统可能运行多个线程同时等待某一个对象。当object.notify()方法被调用时，它就会从这个队列中随机选择一个线程，并将其唤醒。</p>
<p>这个选择是不公平的，并不是先等待线程就会优先被选择，这个选择完全是随机的。</p>
<p>除notify()方法外，Object独享还有一个nofiyAll()方法，它和notify()方法的功能类似，不同的是，它会唤醒在这个等待队列中所有等待的线程，而不是随机选择一个。</p>
<p>强调一点，Object.wait()方法并不能随便调用。它必须包含在对应的synchronize语句汇总，无论是wait()方法或者notify()方法都需要首先获取目标独享的一个监视器。T1和T2表示两个线程。T1在正确执行wait()方法钱，必须获得object对象的监视器。而wait()方法在执行后，会释放这个监视器。这样做的目的是使其他等待在object对象上的线程不至于因为T1的休眠而全部无法正常执行。</p>
<p>上个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Demo06 &#123;</span><br><span class="line">    static Object object = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new T1().start();</span><br><span class="line">        new T2().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:T1 start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:T1 wait for object&quot;);</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:T1 end!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:T2 start，notify one thread! &quot;);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:T2 end!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1562934497212:T1 start!</span><br><span class="line">1562934497212:T1 wait for object</span><br><span class="line">1562934497212:T2 start，notify one thread! </span><br><span class="line">1562934497212:T2 end!</span><br><span class="line">1562934499213:T1 end!</span><br></pre></td></tr></table></figure>

<p>注意下打印结果，T2调用notify方法之后，T1并不能立即继续执行，而是要等待T2释放objec的锁之后，T1重新成功获取锁后，才能继续执行。因此最后2行日志相差了2秒（因为T2调用notify方法后休眠了2秒）。</p>
<h3 id="5-等待线程结束（join）和谦让（yeild）"><a href="#5-等待线程结束（join）和谦让（yeild）" class="headerlink" title="5. 等待线程结束（join）和谦让（yeild）"></a>5. <strong>等待线程结束（join）和谦让（yeild）</strong></h3><p>一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖的线程执行完毕，才能继续执行。</p>
<p>jdk提供了join()操作来实现这个功能。如下所示，显示了2个join()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException;</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>

<p>第1个方法表示无限等待，它会一直只是当前线程。知道目标线程执行完毕。</p>
<p>第2个方法有个参数，用于指定等待时间，如果超过了给定的时间目标线程还在执行，当前线程也会停止等待，而继续往下执行。</p>
<p>比如：线程T1需要等待T2、T3完成之后才能继续执行，那么在T1线程中需要分别调用T2和T3的join()方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Demo08 &#123;</span><br><span class="line">    static int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,num = &quot; + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        public T1(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,start &quot; + this.getName());</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                num++;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(200);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,end &quot; + this.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1562939889129,start t11</span><br><span class="line">562939891134,end t1</span><br><span class="line">1562939891134,num = 10</span><br></pre></td></tr></table></figure>

<p>num的结果为10，1、3行的时间戳相差2秒左右，说明主线程等待t1完成之后才继续执行的。</p>
<p>另外一个方法是**Thread.yield()**，他的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static native void yield();</span><br></pre></td></tr></table></figure>



<p>yield是谦让的意思，这是一个静态方法，一旦执行，它会让当前线程出让CPU。</p>
<p>需要注意的是，出让CPU并不是说不让当前线程执行了，当前线程在出让CPU后，还会进行CPU资源的争夺，但是能否再抢到CPU的执行权就不一定了。</p>
<p>因此，对Thread.yield()方法的调用好像就是在说：我已经完成了一些主要的工作，我可以休息一下了，可以让CPU给其他线程一些工作机会了。</p>
<p>如果觉得一个线程不太重要，或者优先级比较低，而又担心此线程会过多的占用CPU资源，那么可以在适当的时候调用一下Thread.yield()方法，给与其他线程更多的机会。</p>
<p>总结：</p>
<ol>
<li>创建线程的2中方式：继承Thread类；实现Runnable接口</li>
<li>启动线程：调用线程的start()方法</li>
<li>终止线程：调用线程的stop()方法，方法已过时，建议不要使用</li>
<li>线程中断相关的方法：调用线程<strong>实例interrupt()方法</strong>将中断标志置为true；使用**线程实例方法isInterrupted()<strong>获取中断标志；调用</strong>Thread的静态方法interrupted()**获取线程是否被中断，此方法调用之后会清除中断标志（将中断标志置为false了）</li>
<li>wait、notify、notifyAll方法，这块比较难理解，可以回过头去再理理</li>
<li>线程挂起使用**线程实例方法suspend()<strong>，恢复线程使用</strong>线程实例方法resume()**，这2个方法都过时了，不建议使用</li>
<li>等待线程结束：调用<strong>线程实例方法join()</strong></li>
<li>出让cpu资源：调用<strong>线程静态方法yeild()</strong></li>
</ol>
<h2 id="7-volatile与Java内存模型"><a href="#7-volatile与Java内存模型" class="headerlink" title="7. volatile与Java内存模型"></a>7. volatile与Java内存模型</h2><p>先来个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09 &#123;</span><br><span class="line">    public static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new T1(&quot;t1&quot;).start();        //休眠1秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        //将flag置为false</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        public T1(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot; + this.getName() + &quot; in&quot;);</span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程&quot; + this.getName() + &quot;停止了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行上面代码，会发现程序无法终止。</span><br></pre></td></tr></table></figure>

<p>线程t1的run()方法中有个循环，通过flag来控制循环是否结束，主线程中休眠了1秒，将flag置为false，按说此时线程t1会检测到flag为false，打印“线程t1停止了”，为何和我们期望的结果不一样呢？运行上面的代码我们可以判断，t1中看到的flag一直为true，主线程将flag置为false之后，t1线程中并没有看到，所以一直死循环。</p>
<p>那么t1中为什么看不到被主线程修改之后的flag？</p>
<p>要解释这个，我们需要先了解一下java内存模型（JMM），Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>JMM抽象示意图：</p>
<p>![java thread jmm](..&#x2F;..&#x2F;..&#x2F;..&#x2F;images&#x2F;java thread jmm.jpg)</p>
<p>从上图中可以看出，线程1需要和线程2通信，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程1把工作内存1中更新过的共享变量刷新到主内存中去</li>
<li>然后，线程2到主内存中去读取线程1之前已更新过的共享变量</li>
</ol>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。J</p>
<p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<p>我们再看下开头的例子，线程t1中为何看不到被主线程修改为false的flag的值，有两种可能:</p>
<ol>
<li><strong>主线程修改了flag之后，未将其刷新到主内存，所以t1看不到</strong></li>
<li><strong>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中获取flag最新的值</strong></li>
</ol>
<p><strong>对于上面2种情况，有什么办法可以解决？</strong></p>
<p>java帮我们提供了这样的方法，使用<strong>volatile修饰共享变量</strong>，就可以达到上面的效果，被volatile修改的变量有以下特点：</p>
<ol>
<li><strong>线程读取变量的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</strong></li>
<li><strong>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</strong></li>
</ol>
<p>我们修改一下开头的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Demo09 &#123;</span><br><span class="line">    public volatile static boolean flag = true;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new T1(&quot;t1&quot;).start();        //休眠1秒</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        //将flag置为false</span><br><span class="line">        flag = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        public T1(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;线程&quot; + this.getName() + &quot; in&quot;);</span><br><span class="line">            while (flag) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程&quot; + this.getName() + &quot;停止了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用volatile修饰flag变量，然后运行一下程序，输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程t1 in</span><br><span class="line">线程t1停止了</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>volatile解决了共享变量在多线程中可见性的问题，可见性是指一个线程对共享变量的修改，对于另一个线程来说是否是可以看到的。</p>
<h2 id="8-线程组"><a href="#8-线程组" class="headerlink" title="8. 线程组"></a>8. 线程组</h2><h3 id="1-线程组"><a href="#1-线程组" class="headerlink" title="1. 线程组"></a>1. 线程组</h3><p>我们可以把线程归属到某个线程组中，线程组可以包含多个<strong>线程</strong>以及<strong>线程组</strong>，线程和线程组组成了父子关系，是个树形结构，如下图：</p>
<p><img src="/../../../../images/%E7%BA%BF%E7%A8%8B%E7%BB%841.jpg"></p>
<p>使用线程组可以方便管理线程，线程组提供了一些方法方便方便我们管理线程。</p>
<h4 id="1-创建线程关联线程组"><a href="#1-创建线程关联线程组" class="headerlink" title="1. 创建线程关联线程组"></a>1. <strong>创建线程关联线程组</strong></h4><p>创建线程的时候，可以给线程指定一个线程组，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadGroup threadGroup = new ThreadGroup(&quot;thread-group-1&quot;);</span><br><span class="line">        Thread t1 = new Thread(threadGroup, new R1(), &quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(threadGroup, new R1(), &quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;活动线程数:&quot; + threadGroup.activeCount());</span><br><span class="line">        System.out.println(&quot;活动线程组:&quot; + threadGroup.activeGroupCount());</span><br><span class="line">        System.out.println(&quot;线程组名称:&quot; + threadGroup.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class R1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;threadName:&quot; + Thread.currentThread().getName());</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">threadName:t1</span><br><span class="line">threadName:t2</span><br><span class="line">活动线程数:2</span><br><span class="line">活动线程组:0</span><br><span class="line">线程组名称:thread-group-1</span><br></pre></td></tr></table></figure>

<p>**activeCount()**方法可以返回线程组中的所有活动线程数，包含下面的所有子孙节点的线程，由于线程组中的线程是动态变化的，这个值只能是一个估算值。</p>
<h4 id="2-为线程组指定父线程组"><a href="#2-为线程组指定父线程组" class="headerlink" title="2. 为线程组指定父线程组"></a>2. <strong>为线程组指定父线程组</strong></h4><p>创建线程组的时候，可以给其指定一个父线程组，也可以不指定，如果不指定父线程组，则父线程组为当前线程的线程组，java api有2个常用的构造方法用来创建线程组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public ThreadGroup(String name) </span><br><span class="line">public ThreadGroup(ThreadGroup parent, String name)</span><br></pre></td></tr></table></figure>

<p>第一个构造方法未指定父线程组，看一下内部的实现：系统自动获取当前线程的线程组作为默认父线程组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ThreadGroup(String name) &#123;        </span><br><span class="line">	this(Thread.currentThread().getThreadGroup(), name);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-根线程组"><a href="#3-根线程组" class="headerlink" title="3. 根线程组"></a>3. <strong>根线程组</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       System.out.println(Thread.currentThread());</span><br><span class="line">       System.out.println(Thread.currentThread().getThreadGroup());</span><br><span class="line">       System.out.println(Thread.currentThread().getThreadGroup().getParent());</span><br><span class="line">        System.out.println(Thread.currentThread().getThreadGroup().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-批量停止线程"><a href="#4-批量停止线程" class="headerlink" title="4. 批量停止线程"></a>4. <strong>批量停止线程</strong></h4><p>调用线程组**interrupt()**，会将线程组树下的所有子孙线程中断标志置为true，可以用来批量中断线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadGroup threadGroup1 = new ThreadGroup(&quot;thread-group-1&quot;);</span><br><span class="line">        Thread t1 = new Thread(threadGroup1, new R1(), &quot;t1&quot;);</span><br><span class="line">        Thread t2 = new Thread(threadGroup1, new R1(), &quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        ThreadGroup threadGroup2 = new ThreadGroup(threadGroup1, &quot;thread-group-2&quot;);</span><br><span class="line">        Thread t3 = new Thread(threadGroup2, new R1(), &quot;t3&quot;);</span><br><span class="line">        Thread t4 = new Thread(threadGroup2, new R1(), &quot;t4&quot;);</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;-----------threadGroup1信息-----------&quot;);</span><br><span class="line">        threadGroup1.list();</span><br><span class="line">        System.out.println(&quot;----------------------&quot;);</span><br><span class="line">        System.out.println(&quot;停止线程组：&quot; + threadGroup1.getName() + &quot;中的所有子孙线程&quot;);</span><br><span class="line">        threadGroup1.interrupt();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        System.out.println(&quot;----------threadGroup1停止后，输出信息------------&quot;);</span><br><span class="line">        threadGroup1.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class R1 implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            System.out.println(&quot;所属线程组:&quot; + thread.getThreadGroup().getName() + &quot;,线程名称:&quot; + thread.getName());</span><br><span class="line">            while (!thread.isInterrupted()) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程:&quot; + thread.getName() + &quot;停止了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>停止线程之后，通过**list()**方法可以看出输出的信息中不包含已结束的线程了。</p>
<p>建议大家再创建线程或者线程组的时候，给他们取一个有意义的名字，对于计算机来说，可能名字并不重要，但是在系统出问题的时候，你可能会去查看线程堆栈信息，如果你看到的都是t1、t2、t3，估计自己也比较崩溃，如果看到的是httpAccpHandler、dubboHandler类似的名字，应该会好很多。</p>
<h2 id="9-用户线程和守护线程"><a href="#9-用户线程和守护线程" class="headerlink" title="9. 用户线程和守护线程"></a>9. 用户线程和守护线程</h2><p><strong>守护线程</strong>是一种特殊的线程，在后台默默地完成一些<strong>系统性的服务</strong>，比如<strong>垃圾回收线程</strong>、<strong>JIT线程</strong>都是<strong>守护线程</strong>。</p>
<p>与之对应的是<strong>用户线程</strong>，用户线程可以理解为是系统的工作线程，它会<strong>完成这个程序需要完成的业务操作</strong>。</p>
<p>java线程分为用户线程和守护线程，<strong>线程的daemon属性为true表示是守护线程，false表示是用户线程</strong>。</p>
<h3 id="1-守护线程的一些特性"><a href="#1-守护线程的一些特性" class="headerlink" title="1. 守护线程的一些特性"></a>1. 守护线程的一些特性</h3><ul>
<li><strong>当程序中所有的用户线程执行完毕之后，不管守护线程是否结束，系统都会自动退出。</strong></li>
<li><strong>设置守护线程，需要在start()方法之前进行</strong></li>
<li><strong>线程daemon的默认值是父线程的daemon</strong></li>
</ul>
<p>总结:</p>
<ol>
<li>java中的线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li>
<li>程序中的所有的用户线程结束之后，不管守护线程处于什么状态，java虚拟机都会自动退出</li>
<li>调用线程的实例方法setDaemon()来设置线程是否是守护线程</li>
<li>setDaemon()方法必须在线程的start()方法之前调用，在后面调用会报异常，并且不起效</li>
<li>线程的daemon默认值和其父线程一样</li>
</ol>
<h2 id="10-线程安全和synchronized关键字"><a href="#10-线程安全和synchronized关键字" class="headerlink" title="10. 线程安全和synchronized关键字"></a>10. 线程安全和synchronized关键字</h2><h3 id="1-什么是线程安全？"><a href="#1-什么是线程安全？" class="headerlink" title="1. 什么是线程安全？"></a>1. 什么是线程安全？</h3><p>当多个线程去访问同一个类（对象或方法）的时候，该类都能表现出正常的行为（与自己预想的结果一致），那我们就可以所这个类是线程安全的。</p>
<p>看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    static int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void m1() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        T1 t2 = new T1();</span><br><span class="line">        T1 t3 = new T1();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        //等待3个线程结束打印num</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo1.num);</span><br><span class="line">        /**</span><br><span class="line">         * * 打印结果：         </span><br><span class="line">         * * 25572         </span><br><span class="line">         * */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Demo1.m1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Demo1中有个静态变量num，默认值是0，m1()方法中对num++执行10000次，main方法中创建了3个线程用来调用m1()方法，然后调用3个线程的join()方法，用来等待3个线程执行完毕之后，打印num的值。我们期望的结果是30000，运行一下，但真实的结果却不是30000。</p>
<p>上面的程序在多线程中表现出来的结果和预想的结果不一致，说明上面的程序不是线程安全的。</p>
<p>线程安全是并发编程中的重要关注点，造成线程安全问题的主要诱因有两点：</p>
<ol>
<li>一是存在共享数据(也称临界资源)</li>
<li>二是存在多条线程共同操作共享数据</li>
</ol>
<p>因此为了解决这个问题，<strong>需要保证同一时刻有且只有一个线程在操作共享数据</strong>，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫<strong>互斥锁</strong>。</p>
<p>在 Java 中，**关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)**，</p>
<p><strong>同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（！！！即保证可见性，完全可以替代volatile功能）</strong>，这点确实也是很重要的。</p>
<p>么我们把上面的程序做一下调整，在m1()方法上面使用关键字synchronized，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">    static int num = 0;</span><br><span class="line"></span><br><span class="line">    public static synchronized void m1() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        T1 t2 = new T1();</span><br><span class="line">        T1 t3 = new T1();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        //等待3个线程结束打印num</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo1.num);</span><br><span class="line">        /**</span><br><span class="line">         * * 打印结果：         </span><br><span class="line">         * * 30000         </span><br><span class="line">         * */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Demo1.m1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-synchronized主要有3种使用方式"><a href="#2-synchronized主要有3种使用方式" class="headerlink" title="2. synchronized主要有3种使用方式"></a>2. synchronized主要有3种使用方式</h3><ol>
<li>修饰实例方法，作用于当前实例，进入同步代码前需要先获取实例的锁</li>
<li>修饰静态方法，作用于类的Class对象，进入修饰的静态方法前需要先获取类的Class对象的锁</li>
<li>修饰代码块，需要指定加锁对象(记做lockobj)，在进入同步代码块前需要先获取lockobj的锁</li>
</ol>
<h4 id="1-synchronized作用于实例对象"><a href="#1-synchronized作用于实例对象" class="headerlink" title="1. synchronized作用于实例对象"></a>1. synchronized作用于实例对象</h4><p>所谓实例对象锁就是用synchronized修饰实例对象的<strong>实例方法</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Demo2 demo2 = new Demo2();</span><br><span class="line">        T t1 = new T(demo2);</span><br><span class="line">        T t2 = new T(demo2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(demo2.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void add() &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        private final Demo2 demo2;</span><br><span class="line"></span><br><span class="line">        public T(Demo2 demo2) &#123;</span><br><span class="line">            this.demo2 = demo2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                this.demo2.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main()方法中创建了一个对象demo2和2个线程t1、t2，t1、t2中调用demo2的add()方法10000次，add()方法中执行了num++，num++实际上是分3步，获取num，然后将num+1，然后将结果赋值给num，如果t2在t1读取num和num+1之间获取了num的值，那么t1和t2会读取到同样的值，然后执行num++，两次操作之后num是相同的值，最终和期望的结果不一致，造成了线程安全失败，因此我们对add方法加了synchronized来保证线程安全。</p>
<p>注意：m1()方法是实例方法，两个线程操作m1()时，需要先获取demo2的锁，没有获取到锁的，将等待，直到其他线程释放锁为止。</p>
<p>synchronize作用于实例方法需要注意：</p>
<ol>
<li>实例方法上加synchronized，线程安全的前提是，多个线程操作的是<strong>同一个实例</strong>，如果多个线程作用于不同的实例，那么线程安全是无法保证的</li>
<li>同一个实例的多个实例方法上有synchronized，这些方法都是互斥的，同一时间只允许一个线程操作<strong>同一个实例的其中的一个synchronized方法</strong></li>
</ol>
<h4 id="2-synchronized作用于静态方法"><a href="#2-synchronized作用于静态方法" class="headerlink" title="2. synchronized作用于静态方法"></a>2. synchronized作用于静态方法</h4><p>当synchronized作用于静态方法时，锁的对象就是当前类的Class对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">    static int num = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Demo3 demo3 = new Demo3();</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        T t2 = new T();</span><br><span class="line">        T t3 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //等待3个线程结束打印num</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(demo3.num);</span><br><span class="line">        /***</span><br><span class="line">         * 打印结果</span><br><span class="line">         * 30000</span><br><span class="line">         */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void m1() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Demo3.m1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m1()方法是静态方法，有synchronized修饰，锁用于与Demo3.class对象，和下面的写法类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void m1() &#123;</span><br><span class="line">    synchronized (Demo4.class) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-synchronized同步代码块"><a href="#3-synchronized同步代码块" class="headerlink" title="3. synchronized同步代码块"></a>3. synchronized同步代码块</h4><p>除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的<strong>方法体可能比较大</strong>，同时存在一些比较耗时的操作，而<strong>需要同步的代码又只有一小部分</strong>，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了.</p>
<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 implements Runnable &#123;</span><br><span class="line">    static Demo5 instance = new Demo5();</span><br><span class="line">    static int i = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(instance);</span><br><span class="line">        Thread t2 = new Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //省略其他耗时操作....</span><br><span class="line">        // 使用同步代码块对变量i进行同步操作,锁对象为instance</span><br><span class="line">        synchronized (instance) &#123;</span><br><span class="line">            for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象。</p>
<p>每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待。这样也就保证了每次只有一个线程执行i++;操作。</p>
<p>当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//this,当前实例对象锁</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//class对象锁</span><br><span class="line">synchronized (Demo5.class) &#123;</span><br><span class="line">    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析代码是否互斥的方法，先找出synchronized作用的对象是谁，如果多个线程操作的方法中synchronized作用的锁对象一样，那么这些线程同时异步执行这些方法就是互斥的。</p>
<h2 id="11-线程中断的几种方式"><a href="#11-线程中断的几种方式" class="headerlink" title="11. 线程中断的几种方式"></a>11. 线程中断的几种方式</h2><h3 id="1-通过一个变量控制线程中断"><a href="#1-通过一个变量控制线程中断" class="headerlink" title="1. 通过一个变量控制线程中断"></a>1. <strong>通过一个变量控制线程中断</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public volatile static boolean exit = false;</span><br><span class="line"></span><br><span class="line">    public static void setExit() &#123;</span><br><span class="line">        exit = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        setExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                //循环处理业务</span><br><span class="line">                if (exit) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中启动了一个线程，线程的run方法中有个死循环，内部通过exit变量的值来控制是否退出。 <code>TimeUnit.SECONDS.sleep(3);</code>让主线程休眠3秒，此处为什么使用TimeUnit？TimeUnit使用更方便一些，能够很清晰的控制休眠时间，底层还是转换为Thread.sleep实现的。</p>
<p>有个重点：<strong>volatile</strong>关键字，exit变量必须通过这个修饰，如果把这个去掉，程序无法正常退出。volatile控制了变量在多线程中的可见性。</p>
<h3 id="2-通过线程自带的中断标志控制"><a href="#2-通过线程自带的中断标志控制" class="headerlink" title="2. 通过线程自带的中断标志控制"></a>2. <strong>通过线程自带的中断标志控制</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                //循环处理业务                </span><br><span class="line">                if (this.isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程内部有个中断标志，当调用线程的interrupt()实例方法之后，线程的中断标志会被置为true，可以通过线程的实例方法isInterrupted()获取线程的中断标志。</p>
<h3 id="3-线程阻塞状态中如何中断？"><a href="#3-线程阻塞状态中如何中断？" class="headerlink" title="3. 线程阻塞状态中如何中断？"></a>3. <strong>线程阻塞状态中如何中断？</strong></h3><p>在此先补充几点知识：</p>
<ol>
<li><strong>调用线程的interrupt()实例方法，线程的中断标志会被置为true</strong></li>
<li><strong>当线程处于阻塞状态时，调用线程的interrupt()实例方法，线程内部会触发InterruptedException异常，并且会清除线程内部的中断标志（即将中断标志置为false）</strong></li>
</ol>
<p>对于阻塞状态的线程，调用线程的interrupt()方法来引发InterruptedException异常，来中断sleep方法导致的阻塞，需要注意， 参考代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(3);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                //循环处理业务                </span><br><span class="line">                // 下面模拟阻塞代码                </span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    this.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.isInterrupted()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序可以正常结束了，分析一下上面代码，注意几点：</p>
<ol>
<li>main方法中调用了t.interrupt()方法，此时线程t内部的中断标志会置为true</li>
<li>然后会触发run()方法内部的InterruptedException异常，所以运行结果中有异常输出，上面说了，当触发InterruptedException异常时候，线程内部的中断标志又会被清除（变为false），<strong>所以在catch中又调用了this.interrupt();一次</strong>，将中断标志置为false</li>
<li>run()方法中通过this.isInterrupted()来获取线程的中断标志，退出循环（break）</li>
</ol>
<p><strong>总结</strong>：</p>
<ol>
<li>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，可以使用 <code>Thread.interrupt()</code>方式中断该线程，注意此时将会抛出一个<strong>InterruptedException</strong>的异常，同时中断状态将会被复位(由中断状态改为非中断状态)</li>
<li>内部有循环体，可以通过一个变量来作为一个信号控制线程是否中断，注意变量需要volatile修饰</li>
<li>文中的几种方式可以结合起来灵活使用控制线程的中断。</li>
</ol>
<h1 id="2-Java-高并发提高篇"><a href="#2-Java-高并发提高篇" class="headerlink" title="2. Java 高并发提高篇"></a>2. Java 高并发提高篇</h1><h2 id="1-JUC部分"><a href="#1-JUC部分" class="headerlink" title="1. JUC部分"></a>1. JUC部分</h2><p><strong>JUC是什么？</strong></p>
<p>JUC是java.util.concurrent包的简称，在Java5.0添加，目的就是为了更好的支持<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">高并发</a>任务。让开发者进行多线程编程时减少竞争条件和死锁的问题！</p>
<h3 id="1-ReentrantLock重入锁"><a href="#1-ReentrantLock重入锁" class="headerlink" title="1. ReentrantLock重入锁"></a>1. ReentrantLock重入锁</h3><h4 id="1-synchronized的局限性"><a href="#1-synchronized的局限性" class="headerlink" title="1. synchronized的局限性"></a>1. synchronized的局限性</h4><p>synchronized是java内置的关键字，它提供了一种独占的加锁方式。</p>
<p>synchronized的获取和释放锁由jvm实现，用户不需要显示的释放锁，非常方便，然而synchronized也有一定的局限性：</p>
<ol>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞，这个阻塞的过程，用户无法控制</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待</li>
</ol>
<p>JDK1.5之后发布，加入了Doug Lea实现的java.util.concurrent包。包内提供了Lock类，用来提供更多扩展的加锁功能。</p>
<p><strong>Lock弥补了synchronized的局限，提供了更加细粒度的加锁功能。</strong></p>
<h4 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h4><p>ReentrantLock是Lock的默认实现，在聊ReentranLock之前，我们需要先弄清楚一些概念：</p>
<ol>
<li>可重入锁：可重入锁是指同一个线程可以多次获得同一把锁；ReentrantLock和关键字Synchronized都是可重入锁</li>
<li>可中断锁：可中断锁是指线程在获取锁的过程中，是否可以相应线程中断操作。synchronized是不可中断的，ReentrantLock是可中断的</li>
<li>公平锁和非公平锁：公平锁是指多个线程尝试获取同一把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，而不是随机插队的方式获取。synchronized是非公平锁，而ReentrantLock是两种都可以实现，不过默认是非公平锁</li>
</ol>
<h5 id="1-ReentrantLock基本使用"><a href="#1-ReentrantLock基本使用" class="headerlink" title="1. ReentrantLock基本使用"></a>1. ReentrantLock基本使用</h5><p>我们使用3个线程来对一个共享变量++操作，先使用<strong>synchronized</strong>实现，然后使用<strong>ReentrantLock</strong>实现。</p>
<h6 id="1-synchronized方式"><a href="#1-synchronized方式" class="headerlink" title="1. synchronized方式"></a>1. <strong>synchronized</strong>方式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    private static int num = 0;</span><br><span class="line"></span><br><span class="line">    private static synchronized void add() &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        T t2 = new T();</span><br><span class="line">        T t3 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo2.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                Demo2.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h6 id="2-ReentrantLock方式"><a href="#2-ReentrantLock方式" class="headerlink" title="2. ReentrantLock方式"></a>2. ReentrantLock方式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    private static int num = 0;</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        T t2 = new T();</span><br><span class="line">        T t3 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo3.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                Demo3.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ReentrantLock的使用过程：</strong></p>
<ol>
<li><strong>创建锁：ReentrantLock lock &#x3D; new ReentrantLock();</strong></li>
<li><strong>获取锁：lock.lock()</strong></li>
<li><strong>释放锁：lock.unlock();</strong></li>
</ol>
<p>对比上面的代码，与关键字synchronized相比，ReentrantLock锁有明显的操作过程，开发人员必须手动的指定何时加锁，何时释放锁，正是因为这样手动控制。</p>
<p>ReentrantLock对逻辑控制的灵活度要远远胜于关键字synchronized，上面代码需要注意**lock.unlock()**一定要放在finally中，否则，若程序出现了异常，锁没有释放，那么其他线程就再也没有机会获取这个锁了。</p>
<h4 id="3-ReentrantLock是可重入锁"><a href="#3-ReentrantLock是可重入锁" class="headerlink" title="3. ReentrantLock是可重入锁"></a>3. ReentrantLock是可重入锁</h4><p>来验证一下ReentrantLock是可重入锁，实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    private static int num = 0;</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        T t2 = new T();</span><br><span class="line">        T t3 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        t3.join();</span><br><span class="line">        System.out.println(Demo4.num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                Demo4.add();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中add()方法中，当一个线程进入的时候，会执行2次获取锁的操作，运行程序可以正常结束，并输出和期望值一样的30000。</p>
<p>假如ReentrantLock是不可重入的锁，那么同一个线程第2次获取锁的时候由于前面的锁还未释放而导致死锁，程序是无法正常结束的。</p>
<p>ReentrantLock命名也挺好的Re entrant Lock，和其名字一样，可重入锁。</p>
<p>代码中还有几点需要注意：</p>
<ol>
<li><strong>lock()方法和unlock()方法需要成对出现，锁了几次，也要释放几次，否则后面的线程无法获取锁了；可以将add中的unlock删除一个试试，上面代码运行将无法结束</strong></li>
<li><strong>unlock()方法放在finally中执行，保证不管程序是否有异常，锁必定会释放</strong></li>
</ol>
<h4 id="4-ReentrantLock实现公平锁"><a href="#4-ReentrantLock实现公平锁" class="headerlink" title="4. ReentrantLock实现公平锁"></a>4. ReentrantLock实现公平锁</h4><p>在大多数情况下，锁的申请都是非公平的，也就是说，线程1首先请求锁A，接着线程2也请求了锁A。那么当锁A可用时，是线程1可获得锁还是线程2可获得锁呢？</p>
<p>这是不一定的，系统只是会从这个锁的等待队列中随机挑选一个，因此不能保证其公平性。</p>
<p>公平锁的一大特点是：它不会产生饥饿现象，只要你排队，最终还是可以等到资源的；synchronized关键字默认是有jvm内部实现控制的，是非公平锁。</p>
<p>而ReentrantLock，开发者自己设置锁的公平性。</p>
<p>看一下jdk中ReentrantLock的源码，2个构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造方法创建的是非公平锁。</p>
<h4 id="5-ReentrantLock获取锁的过程是可中断的"><a href="#5-ReentrantLock获取锁的过程是可中断的" class="headerlink" title="5. ReentrantLock获取锁的过程是可中断的"></a>5. ReentrantLock获取锁的过程是可中断的</h4><p>对于synchronized关键字，如果一个线程在等待获取锁，最终只有2种结果：</p>
<ol>
<li>要么获取到锁然后继续后面的操作</li>
<li>要么一直等待，直到其他线程释放锁为止</li>
</ol>
<p>而ReentrantLock提供了另外一种可能，就是在等的获取锁的过程中（<strong>发起获取锁请求到还未获取到锁这段时间内</strong>）是可以被中断的，也就是说在等待锁的过程中，程序可以根据需要取消获取锁的请求。有些场景使用这个操作是非常有必要的。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">    private static final ReentrantLock lock1 = new ReentrantLock(false);</span><br><span class="line">    private static final ReentrantLock lock2 = new ReentrantLock(false);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T(&quot;t1&quot;, 1);</span><br><span class="line">        T t2 = new T(&quot;t2&quot;, 2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        int lock;</span><br><span class="line"></span><br><span class="line">        public T(String name, int lock) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (this.lock == 1) &#123;</span><br><span class="line">                    lock1.lockInterruptibly();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    lock2.lockInterruptibly();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    lock2.lockInterruptibly();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    lock1.lockInterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(&quot;中断标志:&quot; + this.isInterrupted());</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                if (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock2.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行一下上面代码，发现程序无法结束，使用jstack查看线程堆栈信息，发现2个线程死锁了。</p>
<p>lock1被线程t1占用，lock2倍线程t2占用，线程t1在等待获取lock2，线程t2在等待获取lock1，都在相互等待获取对方持有的锁，最终产生了死锁。</p>
<p>我们队上面代码改造一下，线程t2一直无法获取到lock1，那么等待5秒之后，我们中断获取锁的操作。主要修改一下main方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T t1 = new T(&quot;t1&quot;, 1);</span><br><span class="line">T t2 = new T(&quot;t2&quot;, 2);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">TimeUnit.SECONDS.sleep(5);</span><br><span class="line">t2.interrupt();</span><br></pre></td></tr></table></figure>

<p>新增了2行代码 <code>TimeUnit.SECONDS.sleep(5);t2.interrupt();</code>，程序可以结束，从运行结果可以看出，代码的31行触发了异常，<strong>中断标志输出：false</strong></p>
<p>t2在31行一直获取不到lock1的锁，主线程中等待了5秒之后，t2线程调用了 <code>interrupt()</code>方法，将线程的中断标志置为true，此时31行会触发 <code>InterruptedException</code>异常，然后线程t2可以继续向下执行，释放了lock2的锁，然后线程t1可以正常获取锁，程序得以继续进行。线程发送中断信号触发InterruptedException异常之后，中断标志将被清空。</p>
<p>关于获取锁的过程中被中断，注意几点:</p>
<ol>
<li><strong>ReentrankLock中必须使用实例方法 lockInterruptibly()获取锁时，在线程调用interrupt()方法之后，才会引发 InterruptedException异常</strong></li>
<li><strong>线程调用interrupt()之后，线程的中断标志会被置为true</strong></li>
<li><strong>触发InterruptedException异常之后，线程的中断标志有会被清空，即置为false</strong></li>
<li><strong>所以当线程调用interrupt()引发InterruptedException异常，中断标志的变化是:false-&gt;true-&gt;false</strong></li>
</ol>
<h4 id="6-ReentrantLock锁申请等待限时"><a href="#6-ReentrantLock锁申请等待限时" class="headerlink" title="6.ReentrantLock锁申请等待限时"></a>6.ReentrantLock锁申请等待限时</h4><p>申请锁等待限时是什么意思？</p>
<p>一般情况下，获取锁的时间我们是不知道的，synchronized关键字获取锁的过程中，只能等待其他线程把锁释放之后才能够有机会获取到锁。所以获取锁的时间有长有短。</p>
<p>ReentrantLock给我们提供了获取锁限时等待的方法 <code>tryLock()</code>，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。</p>
<h5 id="1-tryLock-无参方法"><a href="#1-tryLock-无参方法" class="headerlink" title="1. tryLock() 无参方法"></a>1. tryLock() 无参方法</h5><p>代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo8 &#123;</span><br><span class="line">    private static final ReentrantLock lock1 = new ReentrantLock(false);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T(&quot;t1&quot;);</span><br><span class="line">        T t2 = new T(&quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        public T(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;开始获取锁!&quot;);</span><br><span class="line">                //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回                </span><br><span class="line">                if (lock1.tryLock()) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;获取到了锁!&quot;);</span><br><span class="line">                    //获取到锁之后，休眠5秒                    </span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;未能获取到锁!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中获取锁成功之后，休眠5秒，会导致另外一个线程获取锁失败。tryLock()是立即响应的，中间不会有阻塞。</p>
<h5 id="2-tryLock-有参方法"><a href="#2-tryLock-有参方法" class="headerlink" title="2. tryLock() 有参方法"></a>2. tryLock() 有参方法</h5><p>可以明确设置获取锁的超时时间，该方法签名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException</span><br></pre></td></tr></table></figure>

<p>该方法在指定的时间内不管是否可以获取锁，都会返回结果。</p>
<p>返回true，表示获取锁成功，返回false表示获取失败。</p>
<p>此方法由2个参数，第一个参数是时间类型，是一个枚举，可以表示时、分、秒、毫秒等待，使用比较方便。此方法在执行的过程中，如果调用了线程的中断interrupt()方法，会触发InterruptedException异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo8 &#123;</span><br><span class="line">    private static final ReentrantLock lock1 = new ReentrantLock(false);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T(&quot;t1&quot;);</span><br><span class="line">        T t2 = new T(&quot;t2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        public T(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;开始获取锁!&quot;);</span><br><span class="line">                //获取锁超时时间设置为3秒，3秒内是否能否获取锁都会返回                </span><br><span class="line">                if (lock1.tryLock(3, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;获取到了锁!&quot;);</span><br><span class="line">                    //获取到锁之后，休眠5秒                    </span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + &quot;:&quot; + this.getName() + &quot;未能获取到锁!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock1.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序中调用了ReentrantLock的实例方法 <code>tryLock(3,TimeUnit.SECONDS)</code>，表示获取锁的超时时间是3秒，3秒后不管是否能否获取锁，该方法都会有返回值，获取到锁之后，内部休眠了5秒，会导致另外一个线程获取锁失败。</p>
<p><strong>关于tryLock()方法和tryLock(long timeout, TimeUnit unit)方法，说明一下：</strong></p>
<ol>
<li>都会返回boolean值，结果表示获取锁是否成功</li>
<li>tryLock()方法，不管是否获取成功，都会立即返回；而有参的tryLock方法会尝试在指定的时间内去获取锁，中间会有阻塞的可能，在指定的时间之后会不管是否能够获取锁都会返回结果</li>
<li>tryLock()方法不会响应线程的中断方法；而有参的tryLock方法会响应线程的中断方法，而触发<code>InterruptedException</code>异常，这个从2个方法的声明上可以可以看出来</li>
</ol>
<h4 id="7-ReentrantLock其他常用的方法"><a href="#7-ReentrantLock其他常用的方法" class="headerlink" title="7. ReentrantLock其他常用的方法"></a>7. ReentrantLock其他常用的方法</h4><ol>
<li>isHeldByCurrentThread：实例方法，判断当前线程是否持有ReentrantLock的锁，上面代码中有使用过。</li>
</ol>
<h4 id="8-获取锁的4种方法对比"><a href="#8-获取锁的4种方法对比" class="headerlink" title="8. 获取锁的4种方法对比"></a>8. 获取锁的4种方法对比</h4><table>
<thead>
<tr>
<th><strong>获取锁的方法</strong></th>
<th><strong>是否立即响应(不会阻塞)</strong></th>
<th><strong>是否响应中断</strong></th>
</tr>
</thead>
<tbody><tr>
<td>lock()</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>lockInterruptibly()</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>tryLock()</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>tryLock(long timeout, TimeUnit unit)</td>
<td>×</td>
<td>√</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：</p>
<ol>
<li>ReentrantLock可以实现公平锁和非公平锁</li>
<li>ReentrantLock默认实现的是非公平锁</li>
<li>ReentrantLock的获取锁和释放锁必须成对出现，锁了几次，也要释放几次</li>
<li>释放锁的操作必须放在finally中执行</li>
<li>lockInterruptibly()实例方法可以 响应 线程的中断方法，调用线程的interrupt()方法时，lockInterruptibly()方法会触发 <code>InterruptedException</code>异常</li>
<li>关于 <code>InterruptedException</code>异常说一下，看到方法声明上带有 <code>throwsInterruptedException</code>，表示该方法可以 响应 线程中断，调用线程的interrupt()方法时，这些方法会触发 <code>InterruptedException</code>异常，触发InterruptedException时，线程的中断中断状态会被清除。所以如果程序由于调用 <code>interrupt()</code>方法而触发 <code>InterruptedException</code>异常，线程的标志由默认的false变为ture，然后又变为false</li>
<li>实例方法tryLock()获会尝试获取锁，会立即返回，返回值表示是否获取成功</li>
<li>实例方法tryLock(long timeout, TimeUnit unit)会在指定的时间内尝试获取锁，指定的时间内是否能够获取锁，都会返回，返回值表示是否获取锁成功，该方法会响应线程的中断</li>
</ol>
<h3 id="2-JUC中的Condition对象"><a href="#2-JUC中的Condition对象" class="headerlink" title="2. JUC中的Condition对象"></a>2. JUC中的Condition对象</h3><ol>
<li>synchronized中实现线程等待和唤醒</li>
<li>Condition简介及常用方法介绍及相关示例</li>
<li>使用Condition实现同步阻塞队列</li>
</ol>
<p>Object对象中的wait()，notify()方法，用于线程等待和唤醒等待中的线程，参见 <strong>6.线程的基本操作</strong></p>
<h4 id="1-synchronized中实现线程等待和唤醒"><a href="#1-synchronized中实现线程等待和唤醒" class="headerlink" title="1. synchronized中实现线程等待和唤醒"></a>1. synchronized中实现线程等待和唤醒</h4><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        T2 t2 = new T2();</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备获取锁!&quot;);</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;获取锁成功!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;释放锁成功!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备获取锁!&quot;);</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;获取锁成功!&quot;);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot; notify!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备释放锁!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;释放锁成功!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1655568620814,t1准备获取锁!</span><br><span class="line">1655568620814,t1获取锁成功!</span><br><span class="line">1655568625827,t2准备获取锁!</span><br><span class="line">1655568625827,t2获取锁成功!</span><br><span class="line">1655568625827,t2 notify!</span><br><span class="line">1655568630835,t2准备释放锁!</span><br><span class="line">1655568630835,t2释放锁成功!</span><br><span class="line">1655568630835,t1释放锁成功!</span><br></pre></td></tr></table></figure>

<p>代码结合输出的结果我们分析一下：</p>
<ol>
<li>线程t1先获取锁，然后调用了wait()方法将线程置为等待状态，然后会释放lock的锁</li>
<li>主线程等待5秒之后，启动线程t2，t2获取到了锁，结果中1、3行时间相差5秒左右</li>
<li>t2调用lock.notify()方法，准备将等待在lock上的线程t1唤醒，notify()方法之后又休眠了5秒，看一下输出的5、8可知，notify()方法之后，t1并不能立即被唤醒，需要等到t2将synchronized块执行完毕，释放锁之后，t1才被唤醒</li>
<li>wait()方法和notify()方法必须放在同步块内调用（synchronized块内），否则会报错</li>
</ol>
<h4 id="2-Condition简介及常用方法介绍及相关示例"><a href="#2-Condition简介及常用方法介绍及相关示例" class="headerlink" title="2. Condition简介及常用方法介绍及相关示例"></a>2. Condition简介及常用方法介绍及相关示例</h4><p>在了解Condition之前，需要先了解一下重入锁ReentrantLock，参见 2.1.1 ReentrantLock。</p>
<p>任何一个java对象都天然继承于Object类，在线程间实现通信的往往会应用到Object的几个方法，比如wait()、wait(long timeout)、wait(long timeout, int nanos)与notify()、notifyAll()几个方法实现等待&#x2F;通知机制，同样的， 在java Lock体系下依然会有同样的方法实现等待&#x2F;通知机制。</p>
<p>从整体上来看<strong>Object的wait和notify&#x2F;notify是与对象监视器配合完成线程间的等待&#x2F;通知机制，而Condition是与Lock配合完成等待通知机制</strong>。</p>
<p><strong>前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性</strong>。在<strong>功能特性</strong>上还是有很多的不同：</p>
<ol>
<li>Condition能够支持不响应中断，而通过使用Object方式不支持</li>
<li>Condition能够支持多个等待队列（new 多个Condition对象），而Object方式只能支持一个</li>
<li>Condition能够支持超时时间的设置，而Object不支持</li>
</ol>
<p>Condition由ReentrantLock对象创建，并且可以同时创建多个，Condition接口在使用前必须先调用ReentrantLock的lock()方法获得锁，之后调用Condition接口的await()将释放锁，并且在该Condition上等待，直到有其他线程调用Condition的signal()方法唤醒线程。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 微信公众号：路人甲Java，专注于java技术分享（带你玩转 爬虫、分布式事务、异步消息服务、任务调度、分库分表、大数据等），喜欢请关注！</span><br><span class="line"> */</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        T2 t2 = new T2();</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备获取锁!&quot;);</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;获取锁成功!&quot;);</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;释放锁成功!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备获取锁!&quot;);</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;获取锁成功!&quot;);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot; signal!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;准备释放锁!&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;释放锁成功!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1655569218748,t1准备获取锁!</span><br><span class="line">1655569218748,t1获取锁成功!</span><br><span class="line">1655569223760,t2准备获取锁!</span><br><span class="line">1655569223760,t2获取锁成功!</span><br><span class="line">1655569223760,t2 signal!</span><br><span class="line">1655569228764,t2准备释放锁!</span><br><span class="line">1655569228764,t2释放锁成功!</span><br><span class="line">1655569228764,t1释放锁成功!</span><br></pre></td></tr></table></figure>

<p>Condition.await()方法和Object.wait()方法类似，当使用Condition.await()方法时，需要先获取Condition对象关联的ReentrantLock的锁，在Condition.await()方法被调用时，当前线程会释放这个锁，并且当前线程会进行等待（处于阻塞状态）。</p>
<p>在signal()方法被调用后，系统会从Condition对象的等待队列中唤醒一个线程，一旦线程被唤醒，被唤醒的线程会尝试重新获取锁，一旦获取成功，就可以继续执行了。因此，在signal被调用后，一般需要释放相关的锁，让给其他被唤醒的线程，让他可以继续执行。</p>
<h4 id="Condition常用方法"><a href="#Condition常用方法" class="headerlink" title="Condition常用方法"></a>Condition常用方法</h4><p>Condition接口提供的常用方法有：</p>
<blockquote>
<p><strong>和Object中wait类似的方法</strong></p>
</blockquote>
<ol>
<li>void await() throws InterruptedException:当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程获取Lock从await方法返回，如果在等待状态中被中断会抛出被中断异常；</li>
<li>long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者<strong>超时</strong>；</li>
<li>boolean await(long time, TimeUnit unit) throws InterruptedException：同第二种，支持自定义时间单位，false：表示方法超时之后自动返回的，true：表示等待还未超时时，await方法就返回了（超时之前，被其他线程唤醒了）</li>
<li>boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者<strong>到了某个时间</strong></li>
<li>void awaitUninterruptibly();：当前线程进入等待状态，不会响应线程中断操作，只能通过唤醒的方式让线程继续</li>
</ol>
<blockquote>
<p><strong>和Object的notify&#x2F;notifyAll类似的方法</strong></p>
</blockquote>
<ol>
<li>void signal()：唤醒一个等待在condition上的线程，将该线程从<strong>等待队列</strong>中转移到<strong>同步队列</strong>中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。</li>
<li>void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程</li>
</ol>
<h5 id="Condition-await-过程中被打断"><a href="#Condition-await-过程中被打断" class="headerlink" title="Condition.await()过程中被打断"></a>Condition.await()过程中被打断</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public static class T1 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(&quot;中断标志：&quot; + this.isInterrupted());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        //给t1线程发送中断信号</span><br><span class="line">        System.out.println(&quot;1、t1中断标志：&quot; + t1.isInterrupted());</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(&quot;2、t1中断标志：&quot; + t1.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用condition.await()之后，线程进入阻塞中，调用t1.interrupt()，给t1线程发送中断信号，await()方法内部会检测到线程中断信号，然后触发 <code>InterruptedException</code>异常，线程中断标志被清除。</p>
<p>从输出结果中可以看出，线程t1中断标志的变换过程：false-&gt;true-&gt;false</p>
<h5 id="await-long-time-TimeUnit-unit-超时之后自动返回"><a href="#await-long-time-TimeUnit-unit-超时之后自动返回" class="headerlink" title="await(long time, TimeUnit unit)超时之后自动返回"></a>await(long time, TimeUnit unit)超时之后自动返回</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;,start&quot;);</span><br><span class="line">                boolean r = condition.await(2, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(r);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;,end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1线程等待2秒之后，自动返回继续执行，最后await方法返回false，<strong>await返回false表示超时之后自动返回</strong></p>
<h5 id="await-long-time-TimeUnit-unit-超时之前被唤醒"><a href="#await-long-time-TimeUnit-unit-超时之前被唤醒" class="headerlink" title="await(long time, TimeUnit unit)超时之前被唤醒"></a>await(long time, TimeUnit unit)超时之前被唤醒</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T1 t1 = new T1();</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">        	condition.signal();</span><br><span class="line">        &#125; finally&#123;</span><br><span class="line">        	lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T1 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;,start&quot;);</span><br><span class="line">                boolean r = condition.await(2, TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(r);</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + this.getName() + &quot;,end&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1线程中调用 <code>condition.await(5,TimeUnit.SECONDS);</code>方法会释放锁，等待5秒，主线程休眠1秒，然后获取锁，之后调用signal()方法唤醒t1，输出结果中发现await后过了1秒（1、3行输出结果的时间差），await方法就返回了，并且返回值是true。<strong>true表示await方法超时之前被其他线程唤醒了。</strong></p>
<h4 id="3-使用Condition实现同步阻塞队列"><a href="#3-使用Condition实现同步阻塞队列" class="headerlink" title="3. 使用Condition实现同步阻塞队列"></a>3. 使用Condition实现同步阻塞队列</h4><p>同一个锁支持创建多个Condition, 使用两个Condition来实现一个阻塞队列的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class BlockingQueueDemo&lt;E&gt; &#123;</span><br><span class="line">    int size;</span><br><span class="line">    //阻塞队列最大容量    </span><br><span class="line">    ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    LinkedList&lt;E&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">    //队列底层实现    </span><br><span class="line">    Condition notFull = lock.newCondition();</span><br><span class="line">    //队列满时的等待条件    </span><br><span class="line">    Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    //队列空时的等待条件    </span><br><span class="line">    public BlockingQueueDemo(int size) &#123;</span><br><span class="line">        this.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BlockingQueueDemo&lt;Integer&gt; queue = new BlockingQueueDemo&lt;&gt;(2);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            int data = i;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        queue.enqueue(data);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Integer data = queue.dequeue();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void enqueue(E e) throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (list.size() == size)</span><br><span class="line">                //队列已满,在notFull条件上等待                </span><br><span class="line">                notFull.await();</span><br><span class="line">            list.add(e);</span><br><span class="line">            //入队:加入链表末尾            </span><br><span class="line">            System.out.println(&quot;入队：&quot; + e);</span><br><span class="line">            //通知在notEmpty条件上等待的线程     </span><br><span class="line">            notEmpty.signal();   </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E dequeue() throws InterruptedException &#123;</span><br><span class="line">        E e;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (list.size() == 0)</span><br><span class="line">                //队列为空,在notEmpty条件上等待                </span><br><span class="line">                notEmpty.await();</span><br><span class="line">            e = list.removeFirst();</span><br><span class="line">            //出队:移除链表首元素            </span><br><span class="line">            System.out.println(&quot;出队：&quot; + e);</span><br><span class="line">            //通知在notFull条件上等待的线程    </span><br><span class="line">            notFull.signal();</span><br><span class="line">            return e;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个阻塞队列，大小为3，队列满的时候，会被阻塞，等待其他线程去消费，队列中的元素被消费之后，会唤醒生产者，生产数据进入队列。上面代码将队列大小置为1，可以实现同步阻塞队列，生产1个元素之后，生产者会被阻塞，待消费者消费队列中的元素之后，生产者才能继续工作。</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><ol>
<li><strong>使用condition的步骤：创建condition对象，获取锁，然后调用condition的方法</strong></li>
<li><strong>一个ReentrantLock支持床多个condition对象</strong></li>
<li><strong>voidawait()throwsInterruptedException;方法会释放锁，让当前线程等待，支持唤醒，支持线程中断</strong></li>
<li><strong>voidawaitUninterruptibly();方法会释放锁，让当前线程等待，支持唤醒，不支持线程中断</strong></li>
<li><strong>longawaitNanos(longnanosTimeout)throwsInterruptedException;参数为纳秒，此方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为负数；超时之前被唤醒返回的，结果为正数（表示返回时距离超时时间相差的纳秒数）</strong></li>
<li><strong>booleanawait(longtime,TimeUnitunit)throwsInterruptedException;方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前被唤醒返回的，结果为true</strong></li>
<li><strong>booleanawaitUntil(Datedeadline)throwsInterruptedException;参数表示超时的截止时间点，方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前被唤醒返回的，结果为true</strong></li>
<li><strong>voidsignal();会唤醒一个等待中的线程，然后被唤醒的线程会被加入同步队列，去尝试获取锁</strong></li>
<li><strong>voidsignalAll();会唤醒所有等待中的线程，将所有等待中的线程加入同步队列，然后去尝试获取锁</strong></li>
</ol>
<h3 id="3-JUC中的LockSupport工具类，必备技能"><a href="#3-JUC中的LockSupport工具类，必备技能" class="headerlink" title="3. JUC中的LockSupport工具类，必备技能"></a>3. JUC中的LockSupport工具类，必备技能</h3><ol>
<li><strong>讲解3种让线程等待和唤醒的方法，每种方法配合具体的示例</strong></li>
<li><strong>介绍LockSupport主要用法</strong></li>
<li><strong>对比3种方式，了解他们之间的区别</strong></li>
</ol>
<p><strong>LockSupport</strong>位于<strong>java.util.concurrent</strong>（<strong>简称juc</strong>）包中，算是juc中一个基础类，juc中很多地方都会使用LockSupport，非常重要，希望大家一定要掌握。</p>
<h4 id="1-线程等待与唤醒"><a href="#1-线程等待与唤醒" class="headerlink" title="1. 线程等待与唤醒"></a>1. 线程等待与唤醒</h4><p>关于线程等待&#x2F;唤醒的方法，前面的文章中我们已经讲过2种了：</p>
<ol>
<li>方式1：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li>
<li>方式2：使用juc包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</li>
</ol>
<p>这2种方式，我们先来看一下示例。</p>
<h5 id="1-使用Object类中的方法实现线程等待和唤醒"><a href="#1-使用Object类中的方法实现线程等待和唤醒" class="headerlink" title="1.使用Object类中的方法实现线程等待和唤醒"></a>1.使用Object类中的方法实现线程等待和唤醒</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1线程中调用 <code>lock.wait()</code>方法让t1线程等待，主线程中休眠5秒之后，调用 <code>lock.notify()</code>方法唤醒了t1线程，输出的结果中，两行结果相差5秒左右，程序正常退出。</p>
<p>示例2</p>
<p>我们把上面代码中main方法内部改一下，删除了 <code>synchronized</code>关键字，看看有什么效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中将<strong>synchronized</strong>去掉了，发现调用wait()方法和调用notify()方法都抛出了 <code>IllegalMonitorStateException</code>异常，原因：<strong>Object类中的wait、notify、notifyAll用于线程等待和唤醒的方法，都必须在同步代码中运行（必须用到关键字synchronized）</strong>。</p>
<p><strong>示例3</strong></p>
<p>唤醒方法在等待方法之前执行，线程能够被唤醒么？代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        	try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠1秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">            lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;lock.notify()执行完毕&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出了上面2行之后，程序一直无法结束，t1线程调用wait()方法之后无法被唤醒了，从输出中可见， <code>notify()</code>方法在 <code>wait()</code>方法之前执行了，等待的线程无法被唤醒了。说明：唤醒方法在等待方法之前执行，线程无法被唤醒。</p>
<p><strong>关于Object类中的用户线程等待和唤醒的方法，总结一下：</strong></p>
<ol>
<li><strong>wait()&#x2F;notify()&#x2F;notifyAll()方法都必须放在同步代码（必须在synchronized内部执行）中执行，需要先获取锁</strong></li>
<li><strong>线程唤醒的方法（notify、notifyAll）需要在等待的方法（wait）之后执行，等待中的线程才可能会被唤醒，否则无法唤醒</strong></li>
</ol>
<h5 id="2-使用Condition实现线程的等待和唤醒"><a href="#2-使用Condition实现线程的等待和唤醒" class="headerlink" title="2. 使用Condition实现线程的等待和唤醒"></a>2. 使用Condition实现线程的等待和唤醒</h5><p>关于Condition我们准备了3个示例。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>t1线程启动之后调用 <code>condition.await()</code>方法将线程处于等待中，主线程休眠5秒之后调用 <code>condition.signal()</code>方法将t1线程唤醒成功，输出结果中2个时间戳相差5秒。</p>
<p>示例2：将上面代码中的lock.lock()、lock.unlock()去掉，看看会发生什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有异常发生， <code>condition.await();</code>和 <code>condition.signal();</code>都触发了 <code>IllegalMonitorStateException</code>异常。</p>
<p>原因：<strong>调用condition中线程等待和唤醒的方法的前提是必须要先获取lock的锁</strong>。</p>
<p>示例3:唤醒代码在等待之前执行，线程能够被唤醒么？代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">        	try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(5);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠1秒</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;, condition.signal()执行完毕&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序无法结束，代码结合输出可以看出signal()方法在await()方法之前执行的，最终t1线程无法被唤醒，导致程序无法结束。</p>
<p><strong>关于Condition中方法使用总结：</strong></p>
<ol>
<li><strong>使用Condtion中的线程等待和唤醒方法之前，需要先获取锁。否者会报 IllegalMonitorStateException异常</strong></li>
<li><strong>signal()方法先于await()方法之前调用，线程无法被唤醒</strong></li>
</ol>
<h5 id="3-Object和Condition的局限性"><a href="#3-Object和Condition的局限性" class="headerlink" title="3. Object和Condition的局限性"></a>3. Object和Condition的局限性</h5><p>关于Object和Condtion中线程等待和唤醒的局限性，有以下几点：</p>
<ol>
<li><strong>2中方式中的让线程等待和唤醒的方法能够执行的先决条件是：线程需要先获取锁</strong></li>
<li><strong>唤醒方法需要在等待方法之后调用，线程才能够被唤醒</strong></li>
</ol>
<p>关于这2点，LockSupport都不需要，就能实现线程的等待和唤醒。</p>
<h4 id="2-LockSupport类介绍"><a href="#2-LockSupport类介绍" class="headerlink" title="2. LockSupport类介绍"></a>2. LockSupport类介绍</h4><p>LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程。主要是通过**park()<strong>和</strong>unpark(thread)**方法来实现阻塞和唤醒线程的操作的。</p>
<p><strong>LockSupport中常用的方法</strong></p>
<p><strong>阻塞线程</strong></p>
<ul>
<li>void park()：阻塞当前线程，如果调用<strong>unpark方法</strong>或者<strong>当前线程被中断</strong>，从能从park()方法中返回</li>
<li>void park(Object blocker)：功能同方法1，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</li>
<li>void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性</li>
<li>void parkNanos(Object blocker, long nanos)：功能同方法3，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查</li>
<li>void parkUntil(long deadline)：阻塞当前线程，直到deadline，deadline是一个绝对时间，表示某个时间的毫秒格式</li>
<li>void parkUntil(Object blocker, long deadline)：功能同方法5，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；</li>
</ul>
<p><strong>唤醒线程</strong></p>
<ul>
<li>void unpark(Thread thread):唤醒处于阻塞状态的指定线程</li>
</ul>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class Demo7 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        LockSupport.unpark(t1);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,LockSupport.unpark();执行完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1中调用 <code>LockSupport.park();</code>让当前线程t1等待，主线程休眠了5秒之后，调用 <code>LockSupport.unpark(t1);</code>将t1线程唤醒，输出结果中1、3行结果相差5秒左右，说明t1线程等待5秒之后，被唤醒了。</p>
<p>唤醒方法放在等待方法之前执行，看一下线程是否能够被唤醒呢？</p>
<p><strong>唤醒方法在等待方法之前执行，线程也能够被唤醒，这点是另外2中方法无法做到的。Object和Condition中的唤醒必须在等待之后调用，线程才能被唤醒。而LockSupport中，唤醒的方法不管是在等待之前还是在等待之后调用，线程都能够被唤醒。</strong></p>
<p>park()让线程等待之后，是否能够响应线程中断？代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class Demo9 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; start!&quot;);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;,park()之前中断标志：&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;,park()之后中断标志：&quot; + Thread.currentThread().isInterrupted());</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot; 被唤醒!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠5秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1线程中调用了park()方法让线程等待，主线程休眠了5秒之后，调用 <code>t1.interrupt();</code>给线程t1发送中断信号，然后线程t1从等待中被唤醒了，输出结果中的1、4行结果相差5秒左右，刚好是主线程休眠了5秒之后将t1唤醒了。</p>
<p><strong>结论：park方法可以相应线程中断。</strong></p>
<p><strong>LockSupport.park方法让线程等待之后，唤醒方式有2种：</strong></p>
<ol>
<li><strong>调用LockSupport.unpark方法</strong></li>
<li><strong>调用等待线程的 interrupt()方法，给等待的线程发送中断信号，可以唤醒线程</strong></li>
</ol>
<p>示例4</p>
<p>LockSupport有一个blocker参数，这个参数什么意思，上一个实例代码，大家一看就懂了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line">public class Demo10 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">            LockSupport.park(new BlockerDemo());</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.setName(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class BlockerDemo &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码，然后用jstack查看一下线程的堆栈信息：(jps -l       jstack pid)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;t2&quot; #13 prio=5 os_prio=0 tid=0x00000000293ea800 nid=0x91e0 waiting on condition [0x0000000029c3f000]   </span><br><span class="line">	java.lang.Thread.State: WAITING (parking)        </span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)        </span><br><span class="line">        - parking to wait for  &lt;0x00000007180bfeb0&gt; (a com.itsoku.chat10.Demo10$BlockerDemo)        </span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)        </span><br><span class="line">        at com.itsoku.chat10.Demo10.lambda$main$1(Demo10.java:22)        </span><br><span class="line">        at com.itsoku.chat10.Demo10$$Lambda$2/824909230.run(Unknown Source)        </span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">&quot;t1&quot; #12 prio=5 os_prio=0 tid=0x00000000293ea000 nid=0x9d4 waiting on condition [0x0000000029b3f000]   </span><br><span class="line">	java.lang.Thread.State: WAITING (parking)        </span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)        </span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)        </span><br><span class="line">        at com.itsoku.chat10.Demo10.lambda$main$0(Demo10.java:16)        </span><br><span class="line">        at com.itsoku.chat10.Demo10$$Lambda$1/1389133897.run(Unknown Source)        </span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>代码中，线程t1和t2的不同点是，t2中调用park方法传入了一个BlockerDemo对象，从上面的线程堆栈信息中，发现t2线程的堆栈信息中多了一行 <code>-parking to waitfor&lt;0x00000007180bfeb0&gt;(a com.itsoku.chat10.Demo10$BlockerDemo)</code>，刚好是传入的BlockerDemo对象，park传入的这个参数可以让我们在线程堆栈信息中方便排查问题，其他暂无他用。</p>
<p><strong>线程等待和唤醒的3种方式做个对比</strong></p>
<p>到目前为止，已经说了3种让线程等待和唤醒的方法了</p>
<ol>
<li>方式1：Object中的wait、notify、notifyAll方法</li>
<li>方式2：juc中Condition接口提供的await、signal、signalAll方法</li>
<li>方式3：juc中的LockSupport提供的park、unpark方法</li>
</ol>
<h3 id="4-JUC中的Semaphore（信号量）"><a href="#4-JUC中的Semaphore（信号量）" class="headerlink" title="4. JUC中的Semaphore（信号量）"></a>4. JUC中的Semaphore（信号量）</h3><p>Semaphore（信号量）为多线程协作提供了更为强大的控制方法，前面的文章中我们学了synchronized和重入锁ReentrantLock，这2种锁一次都只能允许一个线程访问一个资源，而信号量可以控制有多少个线程可以访问特定的资源。</p>
<p><strong>Semaphore常用场景：限流</strong></p>
<p>举个例子：</p>
<p>比如有个停车场，有5个空位，门口有个门卫，手中5把钥匙分别对应5个车位上面的锁，来一辆车，门卫会给司机一把钥匙，然后进去找到对应的车位停下来，出去的时候司机将钥匙归还给门卫。停车场生意比较好，同时来了100两车，门卫手中只有5把钥匙，同时只能放5辆车进入，其他车只能等待，等有人将钥匙归还给门卫之后，才能让其他车辆进入。</p>
<p>上面的例子中门卫就相当于Semaphore，车钥匙就相当于许可证，车就相当于线程。</p>
<h4 id="1-Semaphore主要方法"><a href="#1-Semaphore主要方法" class="headerlink" title="1. Semaphore主要方法"></a>1. Semaphore主要方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Semaphore(int permits)：构造方法，参数表示许可证数量，用来创建信号量</span><br><span class="line"></span><br><span class="line">Semaphore(int permits,boolean fair)：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量</span><br><span class="line"></span><br><span class="line">void acquire() throws InterruptedException：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void acquire(int permits) throws InterruptedException ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void acquireUninterruptibly(int permits) ：和acquire(int permits) 方法类似，只是不会响应线程中断</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boolean tryAcquire()：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败</span><br><span class="line"></span><br><span class="line">boolean tryAcquire(int permits)：和tryAcquire()，表示尝试获取permits个许可</span><br><span class="line"></span><br><span class="line">boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false</span><br><span class="line"></span><br><span class="line">boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可</span><br><span class="line"></span><br><span class="line">void release()：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫</span><br><span class="line"></span><br><span class="line">void release(int n)：释放n个许可</span><br><span class="line"></span><br><span class="line">int availablePermits()：当前可用的许可数</span><br></pre></td></tr></table></figure>



<h6 id="1-示例1：Semaphore简单的使用"><a href="#1-示例1：Semaphore简单的使用" class="headerlink" title="1. 示例1：Semaphore简单的使用"></a>1. 示例1：Semaphore简单的使用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static Semaphore semaphore = new Semaphore(2);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new T(&quot;t-&quot; + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        public T(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            try &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + thread.getName() + &quot;,获取许可!&quot;);</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + thread.getName() + &quot;,释放许可!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中 <code>newSemaphore(2)</code>创建了许可数量为2的信号量，每个线程获取1个许可，同时允许两个线程获取许可，从输出中也可以看出，同时有两个线程可以获取许可，其他线程需要等待已获取许可的线程释放许可之后才能运行。为获取到许可的线程会阻塞在 <code>acquire()</code>方法上，直到获取到许可才能继续。</p>
<h6 id="2-示例2：获取不到后，中断并正确释放"><a href="#2-示例2：获取不到后，中断并正确释放" class="headerlink" title="2. 示例2：获取不到后，中断并正确释放"></a>2. 示例2：获取不到后，中断并正确释放</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public static class T extends Thread &#123;</span><br><span class="line">    public T(String name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        //获取许可是否成功            </span><br><span class="line">        boolean acquireSuccess = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            acquireSuccess = true;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + thread.getName() + &quot;,获取许可,当前可用许可数量:&quot; + semaphore.availablePermits());</span><br><span class="line">            //休眠100秒                </span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + thread.getName() + &quot;,运行结束!&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (acquireSuccess) &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + thread.getName() + &quot;,当前可用许可数量:&quot; + semaphore.availablePermits());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    static Semaphore semaphore = new Semaphore(1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T(&quot;t1&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        //休眠1秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        T t2 = new T(&quot;t2&quot;);</span><br><span class="line">        t2.start();</span><br><span class="line">        //休眠1秒        </span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        T t3 = new T(&quot;t3&quot;);</span><br><span class="line">        t3.start();</span><br><span class="line">        //给t2和t3发送中断信号        </span><br><span class="line">        t2.interrupt();</span><br><span class="line">        t3.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="其他一些使用说明"><a href="#其他一些使用说明" class="headerlink" title="其他一些使用说明"></a>其他一些使用说明</h5><ol>
<li>Semaphore默认创建的是非公平的信号量，什么意思呢？这个涉及到公平与非公平。举个例子：5个车位，允许5个车辆进去，来了100辆车，只能进去5辆，其他95在外面排队等着。里面刚好出来了1辆，此时刚好又来了10辆车，这10辆车是直接插队到其他95辆前面去，还是到95辆后面去排队呢？让新来的去排队就表示公平，直接去插队争抢第一个，就表示不公平。对于停车场，排队肯定更好一些。不过对于信号量来说不公平的效率更高一些，所以默认是不公平的。</li>
<li>建议阅读以下Semaphore的源码，对常用的方法有个了解，不需要都记住，用的时候也方便查询就好。</li>
<li>方法中带有 <code>throwsInterruptedException</code>声明的，表示这个方法会响应线程中断信号，什么意思？表示调用线程的 <code>interrupt()</code>方法后，会让这些方法触发 <code>InterruptedException</code>异常，即使这些方法处于阻塞状态，也会立即返回，并抛出 <code>InterruptedException</code>异常，线程中断信号也会被清除。</li>
</ol>
<h3 id="5-JUC中等待多线程完成的工具类CountDownLatch，必备技能"><a href="#5-JUC中等待多线程完成的工具类CountDownLatch，必备技能" class="headerlink" title="5. JUC中等待多线程完成的工具类CountDownLatch，必备技能"></a>5. JUC中等待多线程完成的工具类CountDownLatch，必备技能</h3><ol>
<li><strong>介绍CountDownLatch及使用场景</strong></li>
<li><strong>提供几个示例介绍CountDownLatch的使用</strong></li>
<li><strong>手写一个并行处理任务的工具类</strong></li>
</ol>
<p>假如有这样一个需求，当我们需要解析一个Excel里多个sheet的数据时，可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要统计解析总耗时。分析一下：解析每个sheet耗时可能不一样，总耗时就是最长耗时的那个操作。</p>
<p>最简单的做法是使用join，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        long starTime = System.currentTimeMillis();</span><br><span class="line">        T t1 = new T(&quot;解析sheet1线程&quot;, 2);</span><br><span class="line">        t1.start();</span><br><span class="line">        T t2 = new T(&quot;解析sheet2线程&quot;, 5);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;总耗时:&quot; + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;        </span><br><span class="line">    	//休眠时间（秒）        </span><br><span class="line">        int sleepSeconds;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleepSeconds) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleepSeconds = sleepSeconds;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Thread ct = Thread.currentThread();</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + &quot;,&quot; + ct.getName() + &quot;,开始处理!&quot;);</span><br><span class="line">            try &#123;                </span><br><span class="line">            	//模拟耗时操作，休眠sleepSeconds秒                </span><br><span class="line">                TimeUnit.SECONDS.sleep(this.sleepSeconds);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            long endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + &quot;,&quot; + ct.getName() + &quot;,处理完毕,耗时:&quot; + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中启动了2个解析sheet的线程，第一个耗时2秒，第二个耗时5秒，最终结果中总耗时：5秒。上面的关键技术点是线程的 <code>join()</code>方法，此方法会让当前线程等待被调用的线程完成之后才能继续。</p>
<p>而在JDK1.5之后的并发包中提供的CountDownLatch也可以实现join的这个功能。让当前线程等待被调用的线程完成之后再继续。</p>
<h4 id="1-CountDownLatch介绍"><a href="#1-CountDownLatch介绍" class="headerlink" title="1. CountDownLatch介绍"></a>1. CountDownLatch介绍</h4><p>CountDownLatch称之为闭锁，它可以使一个或一批线程在闭锁上等待，等到其他线程执行完相应操作后，闭锁打开，这些等待的线程才可以继续执行。</p>
<p>确切的说，闭锁在内部维护了一个倒计数器。通过该计数器的值来决定闭锁的状态，从而决定是否允许等待的线程继续执行。</p>
<p><strong>常用方法：</strong></p>
<p>**public CountDownLatch(int count)**：构造方法，count表示计数器的值，不能小于0，否者会报异常。</p>
<p><strong>public void await() throws InterruptedException</strong>：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。</p>
<p><strong>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</strong>：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。</p>
<p>**public void countDown()**：让计数器减1</p>
<p><strong>CountDownLatch使用步骤</strong>：</p>
<ol>
<li>创建CountDownLatch对象</li>
<li>调用其实例方法 <code>await()</code>，让当前线程等待</li>
<li>调用 <code>countDown()</code>方法，让计数器减1</li>
<li>当计数器变为0的时候， <code>await()</code>方法会返回</li>
</ol>
<h5 id="示例1：一个简单的示例"><a href="#示例1：一个简单的示例" class="headerlink" title="示例1：一个简单的示例"></a>示例1：一个简单的示例</h5><p>我们使用CountDownLatch来完成上面示例中使用join实现的功能，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;,主流程start!&quot;);</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        long starTime = System.currentTimeMillis();</span><br><span class="line">        T t1 = new T(&quot;解析sheet1线程&quot;, 2, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        T t2 = new T(&quot;解析sheet2线程&quot;, 5, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;, 主流程end!&quot;);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;总耗时:&quot; + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        //休眠时间（秒）</span><br><span class="line">        int sleepSeconds;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleepSeconds = sleepSeconds;</span><br><span class="line">            this.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Thread ct = Thread.currentThread();</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + &quot;,&quot; + ct.getName() + &quot;,开始处理!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟耗时操作，休眠sleepSeconds秒</span><br><span class="line">                TimeUnit.SECONDS.sleep(this.sleepSeconds);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            long endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + &quot;,&quot; + ct.getName() + &quot;,处理完毕,耗时:&quot; + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中看出，效果和join实现的效果一样，代码中创建了计数器为2的 <code>CountDownLatch</code>，主线程中调用 <code>countDownLatch.await();</code>会让主线程等待，t1、t2线程中模拟执行耗时操作，最终在finally中调用了 <code>countDownLatch.countDown();</code>,此方法每调用一次，CountDownLatch内部计数器会减1，当计数器变为0的时候，主线程中的await()会返回，然后继续执行。</p>
<p>注意：上面的 <code>countDown()</code>这个是必须要执行的方法，所以放在finally中执行。</p>
<h5 id="示例2：等待指定时间"><a href="#示例2：等待指定时间" class="headerlink" title="示例2：等待指定时间"></a>示例2：等待指定时间</h5><p>还是上面的示例，2个线程解析2个sheet，主线程等待2个sheet解析完成。主线程等待2秒，你们还是无法处理完成，就不等待了，直接返回。如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;,主流程start!&quot;);</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(2);</span><br><span class="line"></span><br><span class="line">        long starTime = System.currentTimeMillis();</span><br><span class="line">        T t1 = new T(&quot;解析sheet1线程&quot;, 2, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        T t2 = new T(&quot;解析sheet2线程&quot;, 5, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        boolean result = countDownLatch.await(2, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;, 主流程end!&quot;);</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;总耗时:&quot; + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        //休眠时间（秒）</span><br><span class="line">        int sleepSeconds;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleepSeconds, CountDownLatch countDownLatch) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleepSeconds = sleepSeconds;</span><br><span class="line">            this.countDownLatch = countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Thread ct = Thread.currentThread();</span><br><span class="line">            long startTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(startTime + &quot;,&quot; + ct.getName() + &quot;,开始处理!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟耗时操作，休眠sleepSeconds秒</span><br><span class="line">                TimeUnit.SECONDS.sleep(this.sleepSeconds);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            long endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(endTime + &quot;,&quot; + ct.getName() + &quot;,处理完毕,耗时:&quot; + (endTime - startTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看出，线程2耗时了5秒，主线程耗时了2秒，主线程中调用 <code>countDownLatch.await(2,TimeUnit.SECONDS);</code>，表示最多等2秒，不管计数器是否为0，await方法都会返回，若等待时间内，计数器变为0了，立即返回true，否则超时后返回false。</p>
<h5 id="示例3：2个CountDown结合使用的示例"><a href="#示例3：2个CountDown结合使用的示例" class="headerlink" title="示例3：2个CountDown结合使用的示例"></a>示例3：2个CountDown结合使用的示例</h5><p>有3个人参见跑步比赛，需要先等指令员发指令枪后才能开跑，所有人都跑完之后，指令员喊一声，大家跑完了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;线程 start!&quot;);</span><br><span class="line">        CountDownLatch commanderCd = new CountDownLatch(1);</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(3);</span><br><span class="line">        long starTime = System.currentTimeMillis();</span><br><span class="line">        T t1 = new T(&quot;小张&quot;, 2, commanderCd, countDownLatch);</span><br><span class="line">        t1.start();</span><br><span class="line">        T t2 = new T(&quot;小李&quot;, 5, commanderCd, countDownLatch);</span><br><span class="line">        t2.start();</span><br><span class="line">        T t3 = new T(&quot;路人甲&quot;, 10, commanderCd, countDownLatch);</span><br><span class="line">        t3.start();</span><br><span class="line">        //主线程休眠5秒,模拟指令员准备发枪耗时操作</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,枪响了，大家开始跑&quot;);</span><br><span class="line">        commanderCd.countDown();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;所有人跑完了，主线程耗时:&quot; + (endTime - starTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static class T extends Thread &#123;</span><br><span class="line">    //跑步耗时（秒）</span><br><span class="line">    int runCostSeconds;</span><br><span class="line">    CountDownLatch commanderCd;</span><br><span class="line">    CountDownLatch countDown;</span><br><span class="line"></span><br><span class="line">    public T(String name, int runCostSeconds, CountDownLatch commanderCd, CountDownLatch countDown) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.runCostSeconds = runCostSeconds;</span><br><span class="line">        this.commanderCd = commanderCd;</span><br><span class="line">        this.countDown = countDown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        //等待指令员枪响</span><br><span class="line">        try &#123;</span><br><span class="line">            commanderCd.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread ct = Thread.currentThread();</span><br><span class="line">        long startTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(startTime + &quot;,&quot; + ct.getName() + &quot;,开始跑!&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            //模拟耗时操作，休眠runCostSeconds秒</span><br><span class="line">            TimeUnit.SECONDS.sleep(this.runCostSeconds);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            countDown.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(endTime + &quot;,&quot; + ct.getName() + &quot;,跑步结束,耗时:&quot; + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，t1、t2、t3启动之后，都阻塞在 <code>commanderCd.await();</code>，主线程模拟发枪准备操作耗时5秒，然后调用 <code>commanderCd.countDown();</code>模拟发枪操作，此方法被调用以后，阻塞在 <code>commanderCd.await();</code>的3个线程会向下执行。</p>
<p>主线程调用 <code>countDownLatch.await();</code>之后进行等待，每个人跑完之后，调用 <code>countDown.countDown();</code>通知一下 <code>countDownLatch</code>让计数器减1，最后3个人都跑完了，主线程从 <code>countDownLatch.await();</code>返回继续向下执行。</p>
<h4 id="2-手写一个并行处理任务的工具类"><a href="#2-手写一个并行处理任务的工具类" class="headerlink" title="2. 手写一个并行处理任务的工具类"></a>2. 手写一个并行处理任务的工具类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class TaskDisposeUtils &#123;</span><br><span class="line">    //并行线程数</span><br><span class="line">    public static final int POOL_SIZE;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        POOL_SIZE = Integer.max(Runtime.getRuntime().availableProcessors(), 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 并行处理，并等待结束</span><br><span class="line">     * @param taskList 任务列表</span><br><span class="line">     * @param consumer 消费者</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; void dispose(List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer) throws InterruptedException &#123;</span><br><span class="line">        dispose(true, POOL_SIZE, taskList, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 并行处理，并等待结束</span><br><span class="line">     * @param moreThread 是否多线程执行</span><br><span class="line">     * @param poolSize   线程池大小</span><br><span class="line">     * @param taskList   任务列表</span><br><span class="line">     * @param consumer   消费者</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; void dispose(boolean moreThread, int poolSize, List&lt;T&gt; taskList, Consumer&lt;T&gt; consumer) throws InterruptedException &#123;</span><br><span class="line">        if (CollectionUtils.isEmpty(taskList)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (moreThread &amp;&amp; poolSize &gt; 1) &#123;</span><br><span class="line">            poolSize = Math.min(poolSize, taskList.size());</span><br><span class="line">            ExecutorService executorService = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                executorService = Executors.newFixedThreadPool(poolSize);</span><br><span class="line">                CountDownLatch countDownLatch = new CountDownLatch(taskList.size());</span><br><span class="line">                for (T item : taskList) &#123;</span><br><span class="line">                    executorService.execute(() -&gt; &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            consumer.accept(item);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (executorService != null) &#123;</span><br><span class="line">                    executorService.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (T item : taskList) &#123;</span><br><span class="line">                consumer.accept(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //生成1-10的10个数字，放在list中，相当于10个任务</span><br><span class="line">        List&lt;Integer&gt; list = Stream.iterate(1, a -&gt; a + 1).limit(10).collect(Collectors.toList());</span><br><span class="line">        //启动多线程处理list中的数据，每个任务休眠时间为list中的数值</span><br><span class="line">        TaskDisposeUtils.dispose(list, item -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long startTime = System.currentTimeMillis();</span><br><span class="line">                TimeUnit.SECONDS.sleep(item);</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,任务&quot; + item + &quot;执行完毕，耗时:&quot; + (endTime - startTime));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //上面所有任务处理完毕完毕之后，程序才能继续</span><br><span class="line">        System.out.println(list + &quot;中的任务都处理完毕!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TaskDisposeUtils是一个并行处理的工具类，可以传入n个任务内部使用线程池进行处理，等待所有任务都处理完成之后，方法才会返回。比如我们发送短信，系统中有1万条短信，我们使用上面的工具，每次取100条并行发送，待100个都处理完毕之后，再取一批按照同样的逻辑发送。</strong></p>
<h3 id="6-JUC中的循环屏障CyclicBarrier的6种使用场景"><a href="#6-JUC中的循环屏障CyclicBarrier的6种使用场景" class="headerlink" title="6. JUC中的循环屏障CyclicBarrier的6种使用场景"></a>6. JUC中的循环屏障CyclicBarrier的6种使用场景</h3><ol>
<li><strong>介绍CyclicBarrier</strong></li>
<li><strong>6个示例介绍CyclicBarrier的使用</strong></li>
<li><strong>对比CyclicBarrier和CountDownLatch</strong></li>
</ol>
<h4 id="1-CyclicBarrier简介"><a href="#1-CyclicBarrier简介" class="headerlink" title="1. CyclicBarrier简介"></a>1. CyclicBarrier简介</h4><p>CyclicBarrier通常称为循环屏障。它和CountDownLatch很相似，都可以使线程先等待然后再执行。</p>
<p>不过CountDownLatch是使一批线程等待另一批线程执行完后再执行；而CyclicBarrier只是使等待的线程达到一定数目后再让它们继续执行。</p>
<p>因此，CyclicBarrier内部也有一个计数器,计数器的初始值在创建对象时通过构造参数指定,如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public CyclicBarrier(int parties) &#123;</span><br><span class="line">    this(parties, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每调用一次await()方法都将使阻塞的线程数+1，只有阻塞的线程数达到设定值时屏障才会打开，允许阻塞的所有线程继续执行。</p>
<p>除此之外，CyclicBarrier还有几点需要注意的地方:</p>
<ul>
<li>CyclicBarrier的计数器可以重置而CountDownLatch不行，这意味着CyclicBarrier实例可以被重复使用而CountDownLatch只能被使用一次。而这也是循环屏障 循环二字的语义所在。</li>
<li>CyclicBarrier允许用户自定义barrierAction操作，这是个可选操作，可以在创建CyclicBarrier对象时指定</li>
</ul>
<p>一旦用户在创建CyclicBarrier对象时设置了barrierAction参数，则在阻塞线程数达到设定值屏障打开前，会调用barrierAction的run()方法完成用户自定义的操作。</p>
<h5 id="1-示例1：简单使用CyclicBarrier"><a href="#1-示例1：简单使用CyclicBarrier" class="headerlink" title="1. 示例1：简单使用CyclicBarrier"></a>1. 示例1：简单使用CyclicBarrier</h5><p>公司组织旅游，大家都有经历过，10个人，中午到饭点了，需要等到10个人都到了才能开饭，先到的人坐那等着，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        int sleep;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleep) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟休眠</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                long starTime = System.currentTimeMillis();</span><br><span class="line">                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(this.getName() + &quot;,sleep:&quot; + this.sleep + &quot; 等待了&quot; + (endTime - starTime) + &quot;(ms),开始吃饭了！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            new T(&quot;员工&quot; + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中模拟了10个员工上桌吃饭的场景，等待所有员工都到齐了才能开发，可以看到第10个员工最慢，前面的都在等待第10个员工，员工1等待了9秒，上面代码中调用<code>cyclicBarrier.await();</code>会让当前线程等待。当10个员工都调用了<code>cyclicBarrier.await();</code>之后，所有处于等待中的员工都会被唤醒，然后继续运行。</p>
<h5 id="2-示例2：重复使用CyclicBarrier"><a href="#2-示例2：重复使用CyclicBarrier" class="headerlink" title="2. 示例2：重复使用CyclicBarrier"></a>2. 示例2：重复使用CyclicBarrier</h5><p>对示例1进行改造一下，吃饭完毕之后，所有人都去车上，待所有人都到车上之后，驱车去下一景点玩。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        int sleep;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleep) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //等待吃饭</span><br><span class="line">        void eat() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟休眠</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                long starTime = System.currentTimeMillis();</span><br><span class="line">                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(this.getName() + &quot;,sleep:&quot; + this.sleep + &quot; 等待了&quot; + (endTime - starTime) + &quot;(ms),开始吃饭了！&quot;);</span><br><span class="line"></span><br><span class="line">                //休眠sleep时间，模拟当前员工吃饭耗时</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //等待所有人到齐之后，开车去下一站</span><br><span class="line">        void drive() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long starTime = System.currentTimeMillis();</span><br><span class="line">                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(this.getName() + &quot;,sleep:&quot; + this.sleep + &quot; 等待了&quot; + (endTime - starTime) + &quot;(ms),去下一景点的路上！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //等待所有人到齐之后吃饭，先到的人坐那等着，什么事情不要干</span><br><span class="line">            this.eat();</span><br><span class="line">            //等待所有人到齐之后开车去下一景点，先到的人坐那等着，什么事情不要干</span><br><span class="line">            this.drive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            new T(&quot;员工&quot; + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中CyclicBarrier相当于使用了2次，第一次用于等待所有人到达后开饭，第二次用于等待所有人上车后驱车去下一景点。注意一些先到的员工会在其他人到达之前，都处于等待状态（<code>cyclicBarrier.await();</code>会让当前线程阻塞），无法干其他事情，等到最后一个人到了会唤醒所有人，然后继续。</p>
<blockquote>
<p>CyclicBarrier内部相当于有个计数器（构造方法传入的），每次调用<code>await();</code>后，计数器会减1，并且await()方法会让当前线程阻塞，等待计数器减为0的时候，所有在await()上等待的线程被唤醒，然后继续向下执行，此时计数器又会被还原为创建时的值，然后可以继续再次使用。</p>
</blockquote>
<h5 id="3-示例3：-最后一个线程，需要额外的操作"><a href="#3-示例3：-最后一个线程，需要额外的操作" class="headerlink" title="3. 示例3： 最后一个线程，需要额外的操作"></a>3. 示例3： 最后一个线程，需要额外的操作</h5><p>(barrierAction 自定义屏障打开触发的操作)</p>
<p>还是示例1中的例子，员工10是最后到达的，让所有人都久等了，那怎么办，得给所有人倒酒，然后开饭，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10, () -&gt; &#123;</span><br><span class="line">        //模拟倒酒，花了2秒，又得让其他9个人等2秒</span><br><span class="line">        try &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(2);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;说，不好意思，让大家久等了，给大家倒酒赔罪!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        int sleep;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleep) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟休眠</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                long starTime = System.currentTimeMillis();</span><br><span class="line">                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(this.getName() + &quot;,sleep:&quot; + this.sleep + &quot; 等待了&quot; + (endTime - starTime) + &quot;(ms),开始吃饭了！&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            new T(&quot;员工&quot; + i, i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-示例4：其中一个线程等待中被打断了"><a href="#4-示例4：其中一个线程等待中被打断了" class="headerlink" title="4. 示例4：其中一个线程等待中被打断了"></a>4. 示例4：其中一个线程等待中被打断了</h5><p>员工5等待中，突然接了个电话，有点急事，然后就拿起筷子开吃了，其他人会怎么样呢？看着他吃么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Time;</span><br><span class="line">import java.util.concurrent.BrokenBarrierException;</span><br><span class="line">import java.util.concurrent.CyclicBarrier;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 微信公众号：javacode2018，获取年薪50万java课程</span><br><span class="line"> */</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(10);</span><br><span class="line"></span><br><span class="line">    public static class T extends Thread &#123;</span><br><span class="line">        int sleep;</span><br><span class="line"></span><br><span class="line">        public T(String name, int sleep) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">            this.sleep = sleep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            long starTime = 0, endTime = 0;</span><br><span class="line">            try &#123;</span><br><span class="line">                //模拟休眠</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">                starTime = System.currentTimeMillis();</span><br><span class="line">                //调用await()的时候，当前线程将会被阻塞，需要等待其他员工都到达await了才能继续</span><br><span class="line">                System.out.println(this.getName() + &quot;到了！&quot;);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            endTime = System.currentTimeMillis();</span><br><span class="line">            System.out.println(this.getName() + &quot;,sleep:&quot; + this.sleep + &quot; 等待了&quot; + (endTime - starTime) + &quot;(ms),开始吃饭了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">            int sleep = 0;</span><br><span class="line">            if (i == 10) &#123;</span><br><span class="line">                sleep = 10;</span><br><span class="line">            &#125;</span><br><span class="line">            T t = new T(&quot;员工&quot; + i, sleep);</span><br><span class="line">            t.start();</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                //模拟员工5接了个电话，将自己等待吃饭给打断了</span><br><span class="line">                TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                System.out.println(t.getName() + &quot;,有点急事，我先开干了！&quot;);</span><br><span class="line">                t.interrupt();</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>员工5遇到急事，拿起筷子就是吃，这样好么，当然不好，他这么做了，后面看他这么做了都跟着这么做（这种场景是不是很熟悉，有一个人拿起筷子先吃起来，其他人都跟着上了），直接不等其他人了，拿起筷子就开吃了。CyclicBarrier遇到这种情况就是这么处理的。</p>
<p>员工5的await()方法会触发<code>InterruptedException</code>异常，此时其他等待中的前4个员工，看着5开吃了，自己立即也不等了，内部从<code>await()</code>方法中触发<code>BrokenBarrierException</code>异常，然后也开吃了，后面的6&#x2F;7&#x2F;8&#x2F;9&#x2F;10员工来了以后发现大家都开吃了，自己也不等了，6-10员工调用<code>await()</code>直接抛出了<code>BrokenBarrierException</code>异常，然后继续向下。</p>
<p><strong>结论：</strong></p>
<ol>
<li><strong>内部有一个人把规则破坏了（接收到中断信号），其他人都不按规则来了，不会等待了</strong></li>
<li><strong>接收到中断信号的线程，await方法会触发InterruptedException异常，然后被唤醒向下运行</strong></li>
<li><strong>其他等待中 或者后面到达的线程，会在await()方法上触发<code>BrokenBarrierException</code>异常，然后继续执行</strong></li>
</ol>
<h4 id="2-CountDownLatch和CyclicBarrier的区别"><a href="#2-CountDownLatch和CyclicBarrier的区别" class="headerlink" title="2. CountDownLatch和CyclicBarrier的区别"></a>2. CountDownLatch和CyclicBarrier的区别</h4><p>举例子说明一下：</p>
<p><strong>CountDownLatch示例</strong>:</p>
<p>主管相当于 <strong>CountDownLatch</strong>，干活的小弟相当于做事情的线程。老板交给主管了一个任务，让主管搞完之后立即上报给老板。主管下面有10个小弟，接到任务之后将任务划分为10个小任务分给每个小弟去干，主管一直处于等待状态（主管会调用<code>await()</code>方法，此方法会阻塞当前线程，即父线程等待），让每个小弟干完之后通知一下主管（调用<code>countDown()</code>方法通知主管，此方法会立即返回），主管等到所有的小弟都做完了，会被唤醒，从await()方法上苏醒，然后将结果反馈给老板。期间主管会等待，会等待所有小弟将结果汇报给自己。</p>
<p><strong>而CyclicBarrier是一批线程让自己等待(子线程等待)，等待所有的线程都准备好了，自己才能继续。</strong></p>
<h3 id="7-JAVA线程池"><a href="#7-JAVA线程池" class="headerlink" title="7. JAVA线程池"></a>7. JAVA线程池</h3><ol>
<li>什么是线程池</li>
<li>线程池实现原理</li>
<li>线程池中常见的各种队列</li>
<li>自定义线程创建的工厂</li>
<li>常见的饱和策略</li>
<li>自定义饱和策略</li>
<li>线程池中两种关闭方法有何不同</li>
<li>扩展线程池</li>
<li>合理地配置线程池</li>
<li>线程池中线程数量的配置</li>
</ol>
<h4 id="1-什么是线程池"><a href="#1-什么是线程池" class="headerlink" title="1. 什么是线程池"></a>1. 什么是线程池</h4><p>线程池和数据库连接池的原理也差不多，创建线程去处理业务，可能创建线程的时间比处理业务的时间还长一些，如果系统能够提前为我们创建好线程，我们需要的时候直接拿来使用，用完之后不是直接将其关闭，而是将其返回到线程池中，给其他需要的使用，这样直接节省了创建和销毁的时间，提升了系统的性能。</p>
<p>简单的说，在使用了线程池之后，创建线程变成了从线程池中获取一个空闲的线程，然后使用，关闭线程变成了将线程归还到线程池。</p>
<h4 id="2-线程池实现原理"><a href="#2-线程池实现原理" class="headerlink" title="2. 线程池实现原理"></a>2. 线程池实现原理</h4><p>当向线程池提交一个任务之后，线程池的处理流程如下：</p>
<ol>
<li>判断是否达到核心线程数，若未达到，则直接创建新的线程处理当前传入的任务，否则进入下个流程</li>
<li>线程池中的工作队列是否已满，若未满，则将任务丢入工作队列中先存着等待处理，否则进入下个流程</li>
<li>是否达到最大线程数，若未达到，则创建新的线程处理当前传入的任务，否则交给线程池中的饱和策略进行处理。</li>
</ol>
<p>流程如下图：</p>
<p><img src="/../../../../images/threadpool_1.png" alt="threadpool_1.png"></p>
<p><strong>举个例子，加深理解：</strong></p>
<p>咱们作为开发者，上面都有开发主管，主管下面带领几个小弟干活，CTO给主管授权说，你可以招聘5个小弟干活，新来任务，如果小弟还不到五个，立即去招聘一个来干这个新来的任务，当5个小弟都招来了，再来任务之后，将任务记录到一个表格中，表格中最多记录100个，小弟们会主动去表格中获取任务执行，如果5个小弟都在干活，并且表格中也记录满了，那你可以将小弟扩充到20个，如果20个小弟都在干活，并且存放任务的表也满了，产品经理再来任务后，是直接拒绝，还是让产品自己干，这个由你自己决定，小弟们都尽心尽力在干活，任务都被处理完了，突然公司业绩下滑，几个员工没事干，打酱油，为了节约成本，CTO主管把小弟控制到5人，其他15个人直接被干掉了。所以作为小弟们，别让自己闲着，多干活。</p>
<p><strong>原理：</strong>先找几个人干活，大家都忙于干活，任务太多可以排期，排期的任务太多了，再招一些人来干活，最后干活的和排期都达到上层领导要求的上限了，那需要采取一些其他策略进行处理了。对于长时间不干活的人，考虑将其开掉，节约资源和成本。</p>
<h4 id="3-java中的线程池"><a href="#3-java中的线程池" class="headerlink" title="3. java中的线程池"></a>3. java中的线程池</h4><p>jdk中提供了线程池的具体实现，实现类是：<code>java.util.concurrent.ThreadPoolExecutor</code></p>
<p>主要构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(</span><br><span class="line">int corePoolSize, </span><br><span class="line">int maximumPoolSize, </span><br><span class="line">long keepAliveTime, </span><br><span class="line">TimeUnit unit, </span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue, </span><br><span class="line">ThreadFactory threadFactory, </span><br><span class="line">RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>

<p><strong>corePoolSize</strong>：核心线程大小，当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使有其他空闲线程可以处理任务也会创新线程，等到工作的线程数大于核心线程数时就不会在创建了。如果调用了线程池的<code>prestartAllCoreThreads</code>方法，线程池会提前把核心线程都创造好，并启动。</p>
<p><strong>maximumPoolSize</strong>：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。如果我们使用了无界队列，那么所有的任务都会加入队列，这个参数就没有什么效果了。</p>
<p><strong>keepAliveTime</strong>：线程池的工作线程空闲后，保持存活的时间。如果没有任务处理了，有些线程会空闲，空闲的时间超过了这个值，会被回收掉。如果任务很多，并且每个任务的执行时间比较短，避免线程重复创建和回收，可以调大这个时间，提高线程的利用率。</p>
<p><strong>unit</strong>：keepAliveTIme的时间单位，可以选择的单位有天、小时、分钟、毫秒、微妙、千分之一毫秒和纳秒。类型是一个枚举<code>java.util.concurrent.TimeUnit</code>，这个枚举也经常使用，有兴趣的可以看一下其源码</p>
<p><em><strong>workQueue</strong></em>：工作队列，用于缓存待处理任务的阻塞队列，常见的有4种，后面有介绍</p>
<p><strong>threadFactory</strong>：线程池中创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</p>
<p><em><strong>handler</strong></em>：饱和策略，当线程池无法处理新来的任务了，那么需要提供一种策略处理提交的新任务，默认有4种策略，后面会提到</p>
<p><strong>调用线程池的execute方法处理任务，执行execute方法的过程：</strong></p>
<ol>
<li>判断线程池中运行的线程数是否小于corepoolsize，是：则创建新的线程来处理任务，否：执行下一步</li>
<li>试图将任务添加到workQueue指定的队列中，如果无法添加到队列，进入下一步</li>
<li>判断线程池中运行的线程数是否小于<code>maximumPoolSize</code>，是：则新增线程处理当前传入的任务，否：将任务传递给<code>handler</code>对象<code>rejectedExecution</code>方法处理</li>
</ol>
<p><strong>线程池的使用步骤：</strong></p>
<ol>
<li>调用构造方法创建线程池</li>
<li>调用线程池的方法处理任务</li>
<li>关闭线程池</li>
</ol>
<h4 id="4-线程池使用的简单示例"><a href="#4-线程池使用的简单示例" class="headerlink" title="4. 线程池使用的简单示例"></a>4. 线程池使用的简单示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    static ThreadPoolExecutor executor = new ThreadPoolExecutor(3,</span><br><span class="line">            5,</span><br><span class="line">            10,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(10),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            new ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            String taskName = &quot;任务&quot; + j;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                //模拟任务内部处理耗时</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(j);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + taskName + &quot;处理完毕&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-线程池中常见的工作队列"><a href="#5-线程池中常见的工作队列" class="headerlink" title="5. 线程池中常见的工作队列"></a>5. 线程池中常见的工作队列</h4><p>任务太多的时候，工作队列用于暂时缓存待处理的任务，jdk中常见的5种阻塞队列：</p>
<p><strong>ArrayBlockingQueue</strong>：是一个基于数组结构的有界阻塞队列，此队列按照先进先出原则对元素进行排序</p>
<p><strong>LinkedBlockingQueue</strong>：是一个基于链表结构的阻塞队列，此队列按照先进先出排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法<code>Executors.newFixedThreadPool</code>使用了这个队列。</p>
<p><strong>SynchronousQueue</strong> ：一个不存储元素的阻塞队列，每个插入操作必须等到另外一个线程调用移除操作，否则插入操作一直处理阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法<code>Executors.newCachedThreadPool</code>使用这个队列</p>
<p><strong>PriorityBlockingQueue</strong>：优先级队列，进入队列的元素按照优先级会进行排序</p>
<h6 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h6><h6 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h6><p>前2种队列相关示例就不说了，主要说一下后面2种队列的使用示例。</p>
<h6 id="SynchronousQueue队列的线程池"><a href="#SynchronousQueue队列的线程池" class="headerlink" title="SynchronousQueue队列的线程池"></a>SynchronousQueue队列的线程池</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">            int j = i;</span><br><span class="line">            String taskName = &quot;任务&quot; + j;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;处理&quot; + taskName);</span><br><span class="line">                //模拟任务内部处理耗时</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中使用<code>Executors.newCachedThreadPool()</code>创建线程池，看一下的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;        </span><br><span class="line">    return new ThreadPoolExecutor(</span><br><span class="line">        0, </span><br><span class="line">        Integer.MAX_VALUE,</span><br><span class="line">        60L, </span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        new SynchronousQueue&lt;Runnable&gt;()</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，系统创建了50个线程处理任务，代码中使用了<code>SynchronousQueue</code>同步队列，这种队列比较特殊，放入元素必须要有另外一个线程去获取这个元素，否则放入元素会失败或者一直阻塞在那里直到有线程取走，示例中任务处理休眠了指定的时间，导致已创建的工作线程都忙于处理任务，所以新来任务之后，将任务丢入同步队列会失败，丢入队列失败之后，会尝试新建线程处理任务。使用上面的方式创建线程池需要注意，如果需要处理的任务比较耗时，会导致新来的任务都会创建新的线程进行处理，可能会导致创建非常多的线程，最终耗尽系统资源，触发OOM。</p>
<h6 id="PriorityBlockingQueue优先级队列的线程池"><a href="#PriorityBlockingQueue优先级队列的线程池" class="headerlink" title="PriorityBlockingQueue优先级队列的线程池"></a>PriorityBlockingQueue优先级队列的线程池</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable, Comparable&lt;Task&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private int i;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public Task(int i, String name) &#123;</span><br><span class="line">            this.i = i;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;处理&quot; + this.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compareTo(Task o) &#123;</span><br><span class="line">            return Integer.compare(o.i, this.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executor = new ThreadPoolExecutor(1, 1,</span><br><span class="line">                60L, TimeUnit.SECONDS,</span><br><span class="line">                new PriorityBlockingQueue());</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String taskName = &quot;任务&quot; + i;</span><br><span class="line">            executor.execute(new Task(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 100; i &gt;= 90; i--) &#123;</span><br><span class="line">            String taskName = &quot;任务&quot; + i;</span><br><span class="line">            executor.execute(new Task(i, taskName));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，除了第一个任务，其他任务按照优先级高低按顺序处理。原因在于：创建线程池的时候使用了优先级队列，进入队列中的任务会进行排序，任务的先后顺序由Task中的i变量决定。向<code>PriorityBlockingQueue</code>加入元素的时候，内部会调用代码中Task的<code>compareTo</code>方法决定元素的先后顺序。</p>
<h4 id="6-自定义线程创建的工厂"><a href="#6-自定义线程创建的工厂" class="headerlink" title="6. 自定义线程创建的工厂"></a>6. 自定义线程创建的工厂</h4><p>给线程池中线程起一个有意义的名字，在系统出现问题的时候，通过线程堆栈信息可以更容易发现系统中问题所在。自定义创建工厂需要实现<code>java.util.concurrent.ThreadFactory</code>接口中的<code>Thread newThread(Runnable r)</code>方法，参数为传入的任务，需要返回一个工作线程。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    static AtomicInteger threadNum = new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 5,</span><br><span class="line">                60L, TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(10), r -&gt; &#123;</span><br><span class="line">            Thread thread = new Thread(r);</span><br><span class="line">            thread.setName(&quot;自定义线程-&quot; + threadNum.getAndIncrement());</span><br><span class="line">            return thread;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            String taskName = &quot;任务-&quot; + i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;处理&quot; + taskName);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码中在任务中输出了当前线程的名称，可以看到是我们自定义的名称。</p>
<p>通过jstack查看线程的堆栈信息，也可以看到我们自定义的名称，我们可以将代码中<code>executor.shutdown();</code>先给注释掉让程序先不退出，然后通过jstack查看.</p>
<h4 id="7-常见的饱和策略"><a href="#7-常见的饱和策略" class="headerlink" title="7. 常见的饱和策略"></a>7. 常见的饱和策略</h4><p>当线程池中队列已满，并且线程池已达到最大线程数，线程池会将任务传递给饱和策略进行处理。这些策略都实现了<code>RejectedExecutionHandler</code>接口。接口中有个方法：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void rejectedExecution(Runnable r, ThreadPoolExecutor executor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：</p>
<p><strong>r</strong>：需要执行的任务</p>
<p><strong>executor</strong>：当前线程池对象</p>
</blockquote>
</blockquote>
<p>JDK中提供了4种常见的饱和策略:</p>
<p><strong>AbortPolicy</strong>：直接抛出异常</p>
<p><strong>CallerRunsPolicy</strong>：在当前调用者的线程中运行任务，即谁丢来的任务，由他自己去处理</p>
<p><strong>DiscardOldestPolicy</strong>：丢弃队列中最老的一个任务，即丢弃队列头部的一个任务，然后执行当前传入的任务</p>
<p><strong>DiscardPolicy</strong>：不处理，直接丢弃掉，方法内部为空</p>
<h4 id="8-自定义饱和策略"><a href="#8-自定义饱和策略" class="headerlink" title="8. 自定义饱和策略"></a>8. 自定义饱和策略</h4><p>需要实现<code>RejectedExecutionHandler</code>接口。任务无法处理的时候，我们想记录一下日志，我们需要自定义一个饱和策略，示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Task(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;处理&quot; + this.name);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Task&#123;&quot; +</span><br><span class="line">                    &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(1,</span><br><span class="line">                1,</span><br><span class="line">                60L,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(1),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    //自定义饱和策略</span><br><span class="line">                    //记录一下无法处理的任务</span><br><span class="line">                    System.out.println(&quot;无法处理的任务：&quot; + r.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            executor.execute(new Task(&quot;任务-&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果中可以看到有3个任务进入了饱和策略中，记录了任务的日志，对于无法处理多任务，我们最好能够记录一下，让开发人员能够知道。任务进入了饱和策略，说明线程池的配置可能不是太合理，或者机器的性能有限，需要做一些优化调整。</p>
<h4 id="9-线程池中两种关闭方法有何不同"><a href="#9-线程池中两种关闭方法有何不同" class="headerlink" title="9. 线程池中两种关闭方法有何不同"></a>9. 线程池中两种关闭方法有何不同</h4><p>线程池提供了2个关闭方法：<code>shutdown</code>和<code>shutdownNow</code></p>
<p>当调用者两个方法之后，线程池会遍历内部的工作线程，然后调用每个工作线程的interrrupt方法给线程发送中断信号，内部如果无法响应中断信号的可能永远无法终止，所以如果内部有无线循环的，最好在循环内部检测一下线程的中断信号，合理的退出。</p>
<p>调用这两个方法中任意一个，线程池的<code>isShutdown</code>方法就会返回true，当所有的任务线程都关闭之后，才表示线程池关闭成功，这时调用<code>isTerminaed</code>方法会返回true。</p>
<p><strong>shutdown</strong></p>
<p>调用<code>shutdown</code>方法之后，线程池将不再接口新任务，内部会将所有已提交的任务处理完毕，处理完毕之后，工作线程自动退出。</p>
<p><strong>shutdownNow</strong></p>
<p>而调用<code>shutdownNow</code>方法后，线程池会将还未处理的（在队里等待处理的任务）任务移除，将正在处理中的处理完毕之后，工作线程自动退出。</p>
<p><strong>总结</strong>：</p>
<p>调用哪个方法来关闭线程，应该由提交到线程池的任务特性决定，多数情况下调用<code>shutdown</code>方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow</code>方法。</p>
<h4 id="10-扩展线程池"><a href="#10-扩展线程池" class="headerlink" title="10. 扩展线程池"></a>10. 扩展线程池</h4><p>虽然jdk提供了<code>ThreadPoolExecutor</code>这个高性能线程池，但是如果我们自己想在这个线程池上面做一些扩展，比如，监控每个任务执行的开始时间，结束时间，或者一些其他自定义的功能，我们应该怎么办？</p>
<p><code>ThreadPoolExecutor</code>内部提供了几个方法<code>beforeExecute</code>、<code>afterExecute</code>、<code>terminated</code>，可以由开发人员自己去用这些方法。</p>
<p>看一下线程池内部的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    beforeExecute(wt, task);//任务执行之前调用的方法</span><br><span class="line">    Throwable thrown = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125; catch (RuntimeException x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        throw x;</span><br><span class="line">    &#125; catch (Error x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        throw x;</span><br><span class="line">    &#125; catch (Throwable x) &#123;</span><br><span class="line">        thrown = x;</span><br><span class="line">        throw new Error(x);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        afterExecute(task, thrown);//任务执行完毕之后调用的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    task = null;</span><br><span class="line">    w.completedTasks++;</span><br><span class="line">    w.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>beforeExecute：任务执行之前调用的方法，有2个参数，第1个参数是执行任务的线程，第2个参数是任务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void beforeExecute(Thread t, Runnable r) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>afterExecute：任务执行完成之后调用的方法，2个参数，第1个参数表示任务，第2个参数表示任务执行时的异常信息，如果无异常，第二个参数为null</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void afterExecute(Runnable r, Throwable t) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>terminated：线程池最终关闭之后调用的方法。所有的工作线程都退出了，最终线程池会退出，退出时调用该方法</strong></p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">    static class Task implements Runnable &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        public Task(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;处理&quot; + this.name);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Task&#123;&quot; +</span><br><span class="line">                    &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        ThreadPoolExecutor executor = new ThreadPoolExecutor(10,</span><br><span class="line">                10,</span><br><span class="line">                60L,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                new ArrayBlockingQueue&lt;Runnable&gt;(1),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                (r, executors) -&gt; &#123;</span><br><span class="line">                    //自定义饱和策略</span><br><span class="line">                    //记录一下无法处理的任务</span><br><span class="line">                    System.out.println(&quot;无法处理的任务：&quot; + r.toString());</span><br><span class="line">                &#125;) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void beforeExecute(Thread t, Runnable r) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + t.getName() + &quot;,开始执行任务:&quot; + r.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void afterExecute(Runnable r, Throwable t) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;,任务:&quot; + r.toString() + &quot;，执行完毕!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            protected void terminated() &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;，关闭线程池!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            executor.execute(new Task(&quot;任务-&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果中可以看到，每个需要执行的任务打印了3行日志，执行前由线程池的<code>beforeExecute</code>打印，执行时会调用任务的<code>run</code>方法，任务执行完毕之后，会调用线程池的<code>afterExecute</code>方法，从每个任务的首尾2条日志中可以看到每个任务耗时2秒左右。线程池最终关闭之后调用了<code>terminated</code>方法。</p>
<h4 id="11-合理地配置线程池"><a href="#11-合理地配置线程池" class="headerlink" title="11. 合理地配置线程池"></a>11. 合理地配置线程池</h4><p>要想合理的配置线程池，需要先分析任务的特性，可以冲一下几个角度分析：</p>
<ul>
<li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务</li>
<li>任务的优先级：高、中、低</li>
<li>任务的执行时间：长、中、短</li>
<li>任务的依赖性：是否依赖其他的系统资源，如数据库连接。</li>
</ul>
<p>性质不同任务可以用不同规模的线程池分开处理。</p>
<p>CPU密集型任务应该尽可能小的线程，如配置cpu数量+1个线程的线程池。</p>
<p>IO密集型任务并不是一直在执行任务，不能让cpu闲着，则应配置尽可能多的线程，如：cup数量*2。</p>
<p>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这2个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。</p>
<p>可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获取cpu数量。</p>
<p>优先级不同任务可以对线程池采用优先级队列来处理，让优先级高的先执行。</p>
<p>另外，使用队列的时候建议使用有界队列，有界队列增加了系统的稳定性，如果采用无界队列，任务太多的时候可能导致系统OOM，直接让系统宕机。</p>
<h4 id="12-线程池中线程数量的配置"><a href="#12-线程池中线程数量的配置" class="headerlink" title="12. 线程池中线程数量的配置"></a>12. 线程池中线程数量的配置</h4><p>线程池中总线程大小对系统的性能有一定的影响，我们的目标是希望系统能够发挥最好的性能，过多或者过小的线程数量无法有效的使用机器的性能。在Java Concurrency in Practice书中给出了估算线程池大小的公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ncpu = CUP的数量</span><br><span class="line"></span><br><span class="line">Ucpu = 目标CPU的使用率，0&lt;=Ucpu&lt;=1</span><br><span class="line"></span><br><span class="line">W/C = 等待时间与计算时间的比例</span><br><span class="line"></span><br><span class="line">为保存处理器达到期望的使用率，最优的线程池的大小等于：</span><br><span class="line">Nthreads = Ncpu × Ucpu × (1+W/C)</span><br></pre></td></tr></table></figure>



<h4 id="一些使用建议"><a href="#一些使用建议" class="headerlink" title="一些使用建议"></a>一些使用建议</h4><p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面使线程的创建更加规范，可以<strong>合理控制开辟线程的数量</strong>；另一方面线程的细节管理交给线程池处理，<strong>优化了资源的开销</strong>。</p>
<p>线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式。</p>
<p>这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；</p>
<p>另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p>
<h3 id="8-JUC中的Executor框架1"><a href="#8-JUC中的Executor框架1" class="headerlink" title="8. JUC中的Executor框架1"></a>8. JUC中的Executor框架1</h3><ol>
<li>介绍Executor框架相关内容</li>
<li>介绍Executor</li>
<li>介绍ExecutorService</li>
<li>介绍线程池ThreadPoolExecutor及案例</li>
<li>介绍定时器ScheduledExecutorService及案例</li>
<li>介绍Excecutors类的使用</li>
<li>介绍Future接口</li>
<li>介绍Callable接口</li>
<li>介绍FutureTask的使用</li>
<li>获取异步任务的执行结果的几种方法</li>
</ol>
<h4 id="1-Executors框架介绍"><a href="#1-Executors框架介绍" class="headerlink" title="1. Executors框架介绍"></a>1. Executors框架介绍</h4><p>Executors框架是Doug Lea的神作，通过这个框架，可以很容易的使用线程池高效地处理并行任务。</p>
<p><strong>Excecutor框架主要包含3部分的内容：</strong></p>
<ol>
<li>任务相关的：包含被执行的任务要实现的接口：<strong>Runnable</strong>接口或<strong>Callable</strong>接口</li>
<li>任务的执行相关的：包含任务执行机制的<strong>核心接口Executor</strong>，以及继承自<code>Executor</code>的<code>ExecutorService</code>接口。Executor框架中有两个关键的类实现了ExecutorService接口（<code>ThreadPoolExecutor</code>和<code>ScheduleThreadPoolExecutor</code>）</li>
<li>异步计算结果相关的：包含<strong>接口Future</strong>和<strong>实现Future接口的FutureTask类</strong></li>
</ol>
<h4 id="2-Executor接口"><a href="#2-Executor接口" class="headerlink" title="2. Executor接口"></a>2. Executor接口</h4><p>Executor接口中定义了方法execute(Runable able)，该方法接受一个Runable实例，他来执行一个任务，任务即实现一个Runable接口的类。</p>
<h4 id="3-ExecutorService接口"><a href="#3-ExecutorService接口" class="headerlink" title="3. ExecutorService接口"></a>3. ExecutorService接口</h4><p>ExecutorService继承于Executor接口，他提供了更为丰富的线程实现方法，比如ExecutorService提供关闭自己的方法，以及为跟踪一个或多个异步任务执行状况而生成Future的方法。</p>
<p>ExecutorService有三种状态：运行、关闭、终止。创建后便进入运行状态，当调用了shutdown()方法时，便进入了关闭状态，此时意味着ExecutorService不再接受新的任务，但是他还是会执行已经提交的任务，当所有已经提交了的任务执行完后，便达到终止状态。如果不调用shutdown方法，ExecutorService方法会一直运行下去，系统一般不会主动关闭。</p>
<h4 id="4-ThreadPoolExecutor类"><a href="#4-ThreadPoolExecutor类" class="headerlink" title="4. ThreadPoolExecutor类"></a>4. ThreadPoolExecutor类</h4><p>线程池类，实现了<code>ExecutorService</code>接口中所有方法，该类也是我们经常要用到的，非常重要</p>
<h4 id="5-ScheduleThreadPoolExecutor定时器"><a href="#5-ScheduleThreadPoolExecutor定时器" class="headerlink" title="5. ScheduleThreadPoolExecutor定时器"></a>5. ScheduleThreadPoolExecutor定时器</h4><p>ScheduleThreadPoolExecutor继承自<code>ThreadPoolExecutor</code>，他主要用来延迟执行任务，或者定时执行任务。功能和Timer类似，但是ScheduleThreadPoolExecutor更强大、更灵活一些。Timer后台是单个线程，而ScheduleThreadPoolExecutor可以在创建的时候指定多个线程。</p>
<p>常用方法介绍：</p>
<h5 id="schedule-延迟执行任务1次"><a href="#schedule-延迟执行任务1次" class="headerlink" title="schedule:延迟执行任务1次"></a>schedule:延迟执行任务1次</h5><p>使用<code>ScheduleThreadPoolExecutor的schedule方法</code>，看一下这个方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3个参数：</p>
<p>command：需要执行的任务</p>
<p>delay：需要延迟的时间</p>
<p>unit：参数2的时间单位，是个枚举，可以是天、小时、分钟、秒、毫秒、纳秒等</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutionException;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);</span><br><span class="line">        scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;开始执行&quot;);</span><br><span class="line">            //模拟任务耗时</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(3);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;执行结束&quot;);</span><br><span class="line">        &#125;, 2, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="scheduleAtFixedRate-固定的频率执行任务"><a href="#scheduleAtFixedRate-固定的频率执行任务" class="headerlink" title="scheduleAtFixedRate:固定的频率执行任务"></a>scheduleAtFixedRate:固定的频率执行任务</h5><p>使用<code>ScheduleThreadPoolExecutor的scheduleAtFixedRate</code>方法，该方法设置了执行周期，下一次执行时间相当于是上一次的执行时间加上period，任务每次执行完毕之后才会计算下次的执行时间。</p>
<p>看一下这个方法的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  long initialDelay,</span><br><span class="line">                                                  long period,</span><br><span class="line">                                                  TimeUnit unit);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4个参数：</p>
<p>command：表示要执行的任务</p>
<p>initialDelay：表示延迟多久执行第一次</p>
<p>period：连续执行之间的时间间隔</p>
<p>unit：参数2和参数3的时间单位，是个枚举，可以是天、小时、分钟、秒、毫秒、纳秒等</p>
</blockquote>
<p>假设系统调用scheduleAtFixedRate的时间是T1，那么执行时间如下：</p>
<p>第1次：T1+initialDelay</p>
<p>第2次：T1+initialDelay+period</p>
<p>第3次：T1+initialDelay+2*period</p>
<p>第n次：T1+initialDelay+(n-1)*period</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Time;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        //任务执行计数器</span><br><span class="line">        AtomicInteger count = new AtomicInteger(1);</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            int currCount = count.getAndIncrement();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;开始执行&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;执行结束&quot;);</span><br><span class="line">        &#125;, 1, 1, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中设置的任务第一次执行时间是系统启动之后延迟一秒执行。后面每次时间间隔1秒。</p>
<h5 id="scheduleWithFixedDelay-固定的间隔执行任务"><a href="#scheduleWithFixedDelay-固定的间隔执行任务" class="headerlink" title="scheduleWithFixedDelay:固定的间隔执行任务"></a>scheduleWithFixedDelay:固定的间隔执行任务</h5><p>使用<code>ScheduleThreadPoolExecutor的scheduleWithFixedDelay</code>方法，该方法设置了执行周期，与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     long initialDelay,</span><br><span class="line">                                                     long delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4个参数：</p>
<p>command：表示要执行的任务</p>
<p>initialDelay：表示延迟多久执行第一次</p>
<p>period：表示下次执行时间和上次执行结束时间之间的间隔时间</p>
<p>unit：参数2和参数3的时间单位，是个枚举，可以是天、小时、分钟、秒、毫秒、纳秒等</p>
</blockquote>
<p>假设系统调用scheduleAtFixedRate的时间是T1，那么执行时间如下：</p>
<p>第1次：T1+initialDelay，执行结束时间：E1</p>
<p>第2次：E1+period，执行结束时间：E2</p>
<p>第3次：E2+period，执行结束时间：E3</p>
<p>第4次：E3+period，执行结束时间：E4</p>
<p>第n次：上次执行结束时间+period</p>
<h5 id="定时任务有异常会怎么样？"><a href="#定时任务有异常会怎么样？" class="headerlink" title="定时任务有异常会怎么样？"></a>定时任务有异常会怎么样？</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        //任务执行计数器</span><br><span class="line">        AtomicInteger count = new AtomicInteger(1);</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);</span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            int currCount = count.getAndIncrement();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;开始执行&quot;);</span><br><span class="line">            System.out.println(10 / 0);</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;执行结束&quot;);</span><br><span class="line">        &#125;, 1, 1, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(scheduledFuture.isCancelled());</span><br><span class="line">        System.out.println(scheduledFuture.isDone());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>先说补充点知识</strong>：schedule、scheduleAtFixedRate、scheduleWithFixedDelay这几个方法有个返回值ScheduledFuture，通过<code>ScheduledFuture</code>可以对执行的任务做一些操作，如判断任务是否被取消、是否执行完成。</p>
<p>再回到上面代码，任务中有个10&#x2F;0的操作，会触发异常，发生异常之后没有任何现象，被ScheduledExecutorService内部给吞掉了，然后这个任务再也不会执行了，<code>scheduledFuture.isDone()</code>输出true，表示这个任务已经结束了，再也不会被执行了。</p>
<p><strong>所以如果程序有异常，开发者自己注意处理一下，不然跑着跑着发现任务怎么不跑了，也没有异常输出。</strong></p>
<h5 id="取消定时任务"><a href="#取消定时任务" class="headerlink" title="取消定时任务"></a>取消定时任务</h5><p>可能任务执行一会，想取消执行，可以调用<code>ScheduledFuture</code>的<code>cancel</code>方法，<strong>参数表示是否给任务发送中断信号</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        //任务执行计数器</span><br><span class="line">        AtomicInteger count = new AtomicInteger(1);</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);</span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            int currCount = count.getAndIncrement();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;开始执行&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(2);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;第&quot; + currCount + &quot;次&quot; + &quot;执行结束&quot;);</span><br><span class="line">        &#125;, 1, 1, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        scheduledFuture.cancel(false);</span><br><span class="line">        TimeUnit.SECONDS.sleep(1);</span><br><span class="line">        System.out.println(&quot;任务是否被取消：&quot;+scheduledFuture.isCancelled());</span><br><span class="line">        System.out.println(&quot;任务是否已完成：&quot;+scheduledFuture.isDone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-Executors类"><a href="#6-Executors类" class="headerlink" title="6. Executors类"></a>6. Executors类</h4><p>Executors类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。</p>
<ul>
<li><strong>newSingleThreadExecutor</strong></li>
<li><strong>newFixedThreadPool</strong></li>
<li><strong>newCachedThreadPool</strong></li>
<li><strong>newScheduledThreadPool</strong></li>
</ul>
<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor()</span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建一个单线程的线程池</strong>。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。<strong>如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。</strong>此线程池保证所有任务的执行顺序按照任务的提交顺序执行。内部使用了无限容量的LinkedBlockingQueue阻塞队列来缓存任务，<strong>任务如果比较多，单线程如果处理不过来，会导致队列堆满，引发OOM。</strong></p>
</blockquote>
<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建固定大小的线程池</strong>。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。内部使用了无限容量的LinkedBlockingQueue阻塞队列来缓存任务，<strong>任务如果比较多，如果处理不过来，会导致队列堆满，引发OOM</strong>。</p>
</blockquote>
<h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool()</span><br><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建一个可缓存的线程池</strong>。</p>
<p>如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒处于等待任务到来）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。</p>
<p>此线程池的最大值是Integer的最大值(2^31-1)。内部使用了SynchronousQueue同步队列来缓存任务，<strong>此队列的特性是放入任务时必须要有对应的线程获取任务，任务才可以放入成功</strong>。如果处理的任务比较耗时，任务来的速度也比较快，会创建太多的线程引发OOM。</p>
</blockquote>
<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。</p>
<h4 id="7-Future、Callable接口"><a href="#7-Future、Callable接口" class="headerlink" title="7. Future、Callable接口"></a>7. Future、Callable接口</h4><p><code>Future</code>接口定义了操作异步任务执行一些方法，<strong>如获取异步任务的执行结果、取消任务的执行、判断任务是否被取消、判断任务执行是否完毕</strong>等。</p>
<p><code>Callable</code>接口中定义了需要有返回的任务需要实现的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">	V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，过了一会才去获取子任务的执行结果。</p>
<h5 id="获取异步任务执行结果"><a href="#获取异步任务执行结果" class="headerlink" title="获取异步任务执行结果"></a>获取异步任务执行结果</h5><p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br><span class="line">        Future&lt;Integer&gt; result = executorService.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,start!&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,end!&quot;);</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;,结果：&quot; + result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中创建了一个线程池，调用线程池的<code>submit</code>方法执行任务，submit参数为<code>Callable</code>接口：表示需要执行的任务有返回值，submit方法返回一个<code>Future</code>对象，Future相当于一个凭证，可以在任意时间拿着这个凭证去获取对应任务的执行结果（调用其<code>get</code>方法），代码中调用了<code>result.get()</code>方法之后，此方法会阻塞当前线程直到任务执行结束。</p>
<h5 id="超时获取异步任务执行结果"><a href="#超时获取异步任务执行结果" class="headerlink" title="超时获取异步任务执行结果"></a>超时获取异步任务执行结果</h5><p>可能任务执行比较耗时，比如耗时1分钟，我最多只能等待10秒，如果10秒还没返回，我就去做其他事情了。</p>
<p>刚好get有个超时的方法，声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>

<p><strong>示例代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo8 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(1);</span><br><span class="line">        Future&lt;Integer&gt; result = executorService.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,start!&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,end!&quot;);</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName() + &quot;,结果：&quot; + result.get(3,TimeUnit.SECONDS));</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任务执行中休眠了5秒，get方法获取执行结果，超时时间是3秒，3秒还未获取到结果，get触发了<code>TimeoutException</code>异常，当前线程从阻塞状态苏醒了。</p>
<p><strong>Future其他方法介绍一下</strong></p>
<p><strong>cancel</strong>：取消在执行的任务，参数表示是否对执行的任务发送中断信号，方法声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean cancel(boolean mayInterruptIfRunning);</span><br></pre></td></tr></table></figure>

<p><strong>isCancelled</strong>：用来判断任务是否被取消</p>
<p><strong>isDone</strong>：判断任务是否执行完毕。</p>
<p><strong>总结：从上面可以看出Future、Callable接口需要结合ExecutorService来使用，需要有线程池的支持。</strong></p>
<h4 id="8-FutureTask类"><a href="#8-FutureTask类" class="headerlink" title="8. FutureTask类"></a>8. FutureTask类</h4><p>FutureTask除了实现Future接口，还实现了Runnable接口，因此FutureTask可以交给Executor执行，也可以交给线程执行执行（<strong>Thread有个Runnable的构造方法</strong>），<strong>FutureTask</strong>表示带返回值结果的任务。</p>
<p>我们通过FutureTask类，自己启动一个线程来获取执行结果，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo9 &#123;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(()-&gt;&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,start!&quot;);</span><br><span class="line">            TimeUnit.SECONDS.sleep(5);</span><br><span class="line">            System.out.println(System.currentTimeMillis() + &quot;,&quot; + Thread.currentThread().getName()+&quot;,end!&quot;);</span><br><span class="line">            return 10;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(System.currentTimeMillis()+&quot;,&quot;+Thread.currentThread().getName());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        System.out.println(System.currentTimeMillis()+&quot;,&quot;+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(System.currentTimeMillis()+&quot;,&quot;+Thread.currentThread().getName()+&quot;,结果:&quot;+futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以回过头去看一下上面用线程池的submit方法返回的Future实际类型正是FutureTask对象，有兴趣的可以设置个断点去看看。</strong></p>
<p><strong>FutureTask类还是相当重要的，标记一下。</strong></p>
<h3 id="9-JUC中的Executor框架2"><a href="#9-JUC中的Executor框架2" class="headerlink" title="9. JUC中的Executor框架2"></a>9. JUC中的Executor框架2</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933160&amp;idx=1&amp;sn=62649485b065f68c0fc59bb502ed42df&amp;chksm=88621b16bf159200d5e25d11ab7036c60e3f923da3212ae4dd148753d02593a45ce0e9b886c4&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933160&amp;idx=1&amp;sn=62649485b065f68c0fc59bb502ed42df&amp;chksm=88621b16bf159200d5e25d11ab7036c60e3f923da3212ae4dd148753d02593a45ce0e9b886c4&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<ol>
<li>介绍CompletableFuture</li>
<li>介绍CompletionService</li>
<li>介绍ExecutorCompletionService</li>
</ol>
<h3 id="10-Java中的CAS"><a href="#10-Java中的CAS" class="headerlink" title="10. Java中的CAS"></a>10. Java中的CAS</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933166&amp;idx=1&amp;sn=15e614500676170b76a329efd3255c12&amp;chksm=88621b10bf1592064befc5c9f0d78c56cda25c6d003e1711b85e5bfeb56c9fd30d892178db87&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933166&amp;idx=1&amp;sn=15e614500676170b76a329efd3255c12&amp;chksm=88621b10bf1592064befc5c9f0d78c56cda25c6d003e1711b85e5bfeb56c9fd30d892178db87&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<h3 id="11-JUC底层工具类Unsafe，高手必须要了解"><a href="#11-JUC底层工具类Unsafe，高手必须要了解" class="headerlink" title="11. JUC底层工具类Unsafe，高手必须要了解"></a>11. JUC底层工具类Unsafe，高手必须要了解</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933173&amp;idx=1&amp;sn=80eb550294677b0042fc030f90cce109&amp;chksm=88621b0bbf15921d2274a7bf6afde912fec02a4c3ade9cfb50d03cdce73e07e33d08d35a3b27&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933173&amp;idx=1&amp;sn=80eb550294677b0042fc030f90cce109&amp;chksm=88621b0bbf15921d2274a7bf6afde912fec02a4c3ade9cfb50d03cdce73e07e33d08d35a3b27&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<h3 id="12-JUC中原子类"><a href="#12-JUC中原子类" class="headerlink" title="12. JUC中原子类"></a>12. JUC中原子类</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933181&amp;idx=1&amp;sn=a1e254365d405cdc2e3b8372ecda65ee&amp;chksm=88621b03bf159215ca696c9f81e228d0544a7598b03fe30436babc95c6a95e848161f61b868c&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933181&amp;idx=1&amp;sn=a1e254365d405cdc2e3b8372ecda65ee&amp;chksm=88621b03bf159215ca696c9f81e228d0544a7598b03fe30436babc95c6a95e848161f61b868c&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<h3 id="13-ThreadLocal、InheritableThreadLocal（通俗易懂）"><a href="#13-ThreadLocal、InheritableThreadLocal（通俗易懂）" class="headerlink" title="13. ThreadLocal、InheritableThreadLocal（通俗易懂）"></a>13. ThreadLocal、InheritableThreadLocal（通俗易懂）</h3><h4 id="1-需要解决的问题"><a href="#1-需要解决的问题" class="headerlink" title="1. 需要解决的问题"></a>1. 需要解决的问题</h4><p>一般情况，java开发web系统一般有3层，controller、service、dao，请求到达controller，controller调用service，service调用dao，然后进行处理。</p>
<p>以下一个例子，有3个方法分别模拟controller、service、dao。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">    static AtomicInteger threadIndex = new AtomicInteger(1);</span><br><span class="line">    //创建处理请求的线程池子</span><br><span class="line">    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,</span><br><span class="line">            3,</span><br><span class="line">            60,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;disposeRequestThread-&quot; + threadIndex.getAndIncrement());</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    //记录日志</span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        StackTraceElement stack[] = (new Throwable()).getStackTrace();</span><br><span class="line">        System.out.println(&quot;****&quot; + System.currentTimeMillis() + &quot;,[线程:&quot; + Thread.currentThread().getName() + &quot;],&quot; + stack[1] + &quot;:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟controller</span><br><span class="line">    public static void controller(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;接受请求&quot;);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟service</span><br><span class="line">    public static void service(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行业务&quot;);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟dao</span><br><span class="line">    public static void dao(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行数据库操作&quot;);</span><br><span class="line">        //模拟插入数据</span><br><span class="line">        for (String s : dataList) &#123;</span><br><span class="line">            log(&quot;插入数据&quot; + s + &quot;成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //需要插入的数据</span><br><span class="line">        List&lt;String&gt; dataList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            dataList.add(&quot;数据&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模拟5个请求</span><br><span class="line">        int requestCount = 5;</span><br><span class="line">        for (int i = 0; i &lt; requestCount; i++) &#123;</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                controller(dataList);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中调用controller、service、dao 3个方法时，来模拟处理一个请求。main方法中循环了5次模拟发起5次请求，然后交给线程池去处理请求，dao中模拟循环插入传入的dataList数据。</p>
<p><strong>问题来了：开发者想看一下哪些地方耗时比较多，想通过日志来分析耗时情况，想追踪某个请求的完整日志，怎么搞？</strong></p>
<p>上面的请求采用线程池的方式处理的，多个请求可能会被一个线程处理，通过日志很难看出那些日志是同一个请求，我们能不能给请求加一个唯一标志，日志中输出这个唯一标志。</p>
<p>给每个方法加个traceId参数，log方法也加个traceId参数，就解决了。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    static AtomicInteger threadIndex = new AtomicInteger(1);</span><br><span class="line">    //创建处理请求的线程池子</span><br><span class="line">    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,</span><br><span class="line">            3,</span><br><span class="line">            60,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;disposeRequestThread-&quot; + threadIndex.getAndIncrement());</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    //记录日志</span><br><span class="line">    public static void log(String msg, String traceId) &#123;</span><br><span class="line">        StackTraceElement stack[] = (new Throwable()).getStackTrace();</span><br><span class="line">        System.out.println(&quot;****&quot; + System.currentTimeMillis() + &quot;[traceId:&quot; + traceId + &quot;],[线程:&quot; + Thread.currentThread().getName() + &quot;],&quot; + stack[1] + &quot;:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟controller</span><br><span class="line">    public static void controller(List&lt;String&gt; dataList, String traceId) &#123;</span><br><span class="line">        log(&quot;接受请求&quot;, traceId);</span><br><span class="line">        service(dataList, traceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟service</span><br><span class="line">    public static void service(List&lt;String&gt; dataList, String traceId) &#123;</span><br><span class="line">        log(&quot;执行业务&quot;, traceId);</span><br><span class="line">        dao(dataList, traceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟dao</span><br><span class="line">    public static void dao(List&lt;String&gt; dataList, String traceId) &#123;</span><br><span class="line">        log(&quot;执行数据库操作&quot;, traceId);</span><br><span class="line">        //模拟插入数据</span><br><span class="line">        for (String s : dataList) &#123;</span><br><span class="line">            log(&quot;插入数据&quot; + s + &quot;成功&quot;, traceId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //需要插入的数据</span><br><span class="line">        List&lt;String&gt; dataList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            dataList.add(&quot;数据&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模拟5个请求</span><br><span class="line">        int requestCount = 5;</span><br><span class="line">        for (int i = 0; i &lt; requestCount; i++) &#123;</span><br><span class="line">            String traceId = String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                controller(dataList, traceId);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们通过修改代码的方式，把问题解决了，但前提是你们的系统都像上面这么简单，功能很少，需要改的代码很少，可以这么去改。但事与愿违，我们的系统一般功能都是比较多的，如果我们都一个个去改，岂不是要疯掉，改代码还涉及到重新测试，风险也不可控。那有什么好办法么？</p>
<p>答案就是 ThreadLocal</p>
<h4 id="2-介绍ThreadLocal"><a href="#2-介绍ThreadLocal" class="headerlink" title="2. 介绍ThreadLocal"></a>2. 介绍ThreadLocal</h4><p>上面的问题，我们来分析一下，每个请求都是由一个线程处理的，线程就相当于一个人一样，每个请求相当于一个任务，任务来了，人来处理，处理完毕之后，再处理下一个请求任务。</p>
<p>人刚开始准备处理任务的时候，我们把任务的编号放在处理者的口袋中，然后处理中一路携带者，处理过程中如果需要用到这个编号，直接从口袋中获取就可以了。</p>
<p>那么刚好java中线程设计的时候也考虑到了这些问题，Thread对象中就有很多口袋，用来放东西。Thread类中有这么一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure>

<p>这个就是用来操作Thread中所有口袋的东西，<code>ThreadLocalMap</code>源码中有一个数组, 对应处理者身上很多口袋一样，数组中的每个元素对应一个口袋。</p>
<p>java为我们提供了一个类<code>ThreadLocal</code>，ThreadLocal对象用来操作Thread中的某一个口袋，可以向这个口袋中放东西、获取里面的东西、清除里面的东西，这个口袋一次性只能放一个东西，重复放东西会将里面已经存在的东西覆盖掉。</p>
<p>常用的3个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向Thread中某个口袋中放东西</span><br><span class="line">public void set(T value);</span><br><span class="line"></span><br><span class="line">//获取这个口袋中目前放的东西</span><br><span class="line">public T get();</span><br><span class="line"></span><br><span class="line">//清空这个口袋中放的东西</span><br><span class="line">public void remove()</span><br></pre></td></tr></table></figure>



<p>我们使用ThreadLocal来改造一下上面的代码，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line"></span><br><span class="line">    //创建一个操作Thread中存放请求任务追踪id口袋的对象</span><br><span class="line">    static ThreadLocal&lt;String&gt; traceIdKD = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static AtomicInteger threadIndex = new AtomicInteger(1);</span><br><span class="line">    //创建处理请求的线程池子</span><br><span class="line">    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,</span><br><span class="line">            3,</span><br><span class="line">            60,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;disposeRequestThread-&quot; + threadIndex.getAndIncrement());</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    //记录日志</span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        StackTraceElement stack[] = (new Throwable()).getStackTrace();</span><br><span class="line">        //获取当前线程存放tranceId口袋中的内容</span><br><span class="line">        String traceId = traceIdKD.get();</span><br><span class="line">        System.out.println(&quot;****&quot; + System.currentTimeMillis() + &quot;[traceId:&quot; + traceId + &quot;],[线程:&quot; + Thread.currentThread().getName() + &quot;],&quot; + stack[1] + &quot;:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟controller</span><br><span class="line">    public static void controller(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;接受请求&quot;);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟service</span><br><span class="line">    public static void service(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行业务&quot;);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟dao</span><br><span class="line">    public static void dao(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行数据库操作&quot;);</span><br><span class="line">        //模拟插入数据</span><br><span class="line">        for (String s : dataList) &#123;</span><br><span class="line">            log(&quot;插入数据&quot; + s + &quot;成功&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //需要插入的数据</span><br><span class="line">        List&lt;String&gt; dataList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            dataList.add(&quot;数据&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模拟5个请求</span><br><span class="line">        int requestCount = 5;</span><br><span class="line">        for (int i = 0; i &lt; requestCount; i++) &#123;</span><br><span class="line">            String traceId = String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                //把traceId放入口袋中</span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                try &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //将tranceId从口袋中移除</span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出输出和刚才使用traceId参数的方式结果一致，但是却简单了很多。</p>
<p>代码中创建了一个<code>ThreadLocal traceIdKD</code>，这个对象用来操作Thread中一个口袋，用这个口袋来存放tranceId。</p>
<p>在main方法中通过<code>traceIdKD.set(traceId)</code>方法将traceId放入口袋，log方法中通<code>traceIdKD.get()</code>获取口袋中的traceId，最后任务处理完之后，main中的finally中调用<code>traceIdKD.remove();</code>将口袋中的traceId清除。</p>
<p><strong>ThreadLocal的官方API解释为：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。”</span><br></pre></td></tr></table></figure>



<h4 id="3-介绍InheritableThreadLocal"><a href="#3-介绍InheritableThreadLocal" class="headerlink" title="3. 介绍InheritableThreadLocal"></a>3. 介绍InheritableThreadLocal</h4><p>继续上面的实例，dao中循环处理dataList的内容，假如dataList处理比较耗时，我们想加快处理速度有什么办法么？大家已经想到了，用多线程并行处理<code>dataList</code>，那么我们把代码改一下，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line"></span><br><span class="line">    //创建一个操作Thread中存放请求任务追踪id口袋的对象</span><br><span class="line">    static ThreadLocal&lt;String&gt; traceIdKD = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static AtomicInteger threadIndex = new AtomicInteger(1);</span><br><span class="line">    //创建处理请求的线程池子</span><br><span class="line">    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,</span><br><span class="line">            3,</span><br><span class="line">            60,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;disposeRequestThread-&quot; + threadIndex.getAndIncrement());</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    //记录日志</span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        StackTraceElement stack[] = (new Throwable()).getStackTrace();</span><br><span class="line">        //获取当前线程存放tranceId口袋中的内容</span><br><span class="line">        String traceId = traceIdKD.get();</span><br><span class="line">        System.out.println(&quot;****&quot; + System.currentTimeMillis() + &quot;[traceId:&quot; + traceId + &quot;],[线程:&quot; + Thread.currentThread().getName() + &quot;],&quot; + stack[1] + &quot;:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟controller</span><br><span class="line">    public static void controller(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;接受请求&quot;);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟service</span><br><span class="line">    public static void service(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行业务&quot;);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟dao</span><br><span class="line">    public static void dao(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(dataList.size());</span><br><span class="line"></span><br><span class="line">        log(&quot;执行数据库操作&quot;);</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        //模拟插入数据</span><br><span class="line">        for (String s : dataList) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //模拟数据库操作耗时100毫秒</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">                    log(&quot;插入数据&quot; + s + &quot;成功,主线程：&quot; + threadName);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //等待上面的dataList处理完毕</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //需要插入的数据</span><br><span class="line">        List&lt;String&gt; dataList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            dataList.add(&quot;数据&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模拟5个请求</span><br><span class="line">        int requestCount = 5;</span><br><span class="line">        for (int i = 0; i &lt; requestCount; i++) &#123;</span><br><span class="line">            String traceId = String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                //把traceId放入口袋中</span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                try &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //将tranceId从口袋中移除</span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下上面的输出，有些traceId为null，这是为什么呢？这是因为dao中为了提升处理速度，创建了子线程来并行处理，子线程调用log的时候，去自己的存放traceId的口袋中去拿东西，肯定是空的了。</p>
<p>那有什么办法么？</p>
<p>父线程相当于主管，子线程相当于干活的小弟，主管让小弟们干活的时候，将自己兜里面的东西复制一份给小弟们使用，然后小弟就可以从自己的兜里拿去这些东西使用了，也可以清空自己兜里面的东西。</p>
<p><code>Thread</code>对象中有个<code>inheritableThreadLocals</code>变量，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;</span><br></pre></td></tr></table></figure>

<p>inheritableThreadLocals相当于线程中另外一种兜，这种兜有什么特征呢，当创建子线程的时候，子线程会将父线程这种类型兜的东西全部复制一份放到自己的<code>inheritableThreadLocals</code>兜中，使用<code>InheritableThreadLocal</code>对象可以操作线程中的<code>inheritableThreadLocals</code>兜。</p>
<p><code>InheritableThreadLocal</code>常用的方法也有3个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向Thread中某个口袋中放东西</span><br><span class="line">public void set(T value);</span><br><span class="line"></span><br><span class="line">//获取这个口袋中目前放的东西</span><br><span class="line">public T get();</span><br><span class="line"></span><br><span class="line">//清空这个口袋中放的东西</span><br><span class="line">public void remove()</span><br></pre></td></tr></table></figure>



<p>使用<code>InheritableThreadLocal</code>解决上面子线程中无法输出traceId的问题，只需要将上一个示例代码中的<code>ThreadLocal</code>替换成<code>InheritableThreadLocal</code>即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">import java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line">import java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line"></span><br><span class="line">    //创建一个操作Thread中存放请求任务追踪id口袋的对象,子线程可以继承父线程中内容</span><br><span class="line">    static InheritableThreadLocal&lt;String&gt; traceIdKD = new InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static AtomicInteger threadIndex = new AtomicInteger(1);</span><br><span class="line">    //创建处理请求的线程池子</span><br><span class="line">    static ThreadPoolExecutor disposeRequestExecutor = new ThreadPoolExecutor(3,</span><br><span class="line">            3,</span><br><span class="line">            60,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingDeque&lt;&gt;(),</span><br><span class="line">            r -&gt; &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;disposeRequestThread-&quot; + threadIndex.getAndIncrement());</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    //记录日志</span><br><span class="line">    public static void log(String msg) &#123;</span><br><span class="line">        StackTraceElement stack[] = (new Throwable()).getStackTrace();</span><br><span class="line">        //获取当前线程存放tranceId口袋中的内容</span><br><span class="line">        String traceId = traceIdKD.get();</span><br><span class="line">        System.out.println(&quot;****&quot; + System.currentTimeMillis() + &quot;[traceId:&quot; + traceId + &quot;],[线程:&quot; + Thread.currentThread().getName() + &quot;],&quot; + stack[1] + &quot;:&quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟controller</span><br><span class="line">    public static void controller(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;接受请求&quot;);</span><br><span class="line">        service(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟service</span><br><span class="line">    public static void service(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        log(&quot;执行业务&quot;);</span><br><span class="line">        dao(dataList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟dao</span><br><span class="line">    public static void dao(List&lt;String&gt; dataList) &#123;</span><br><span class="line">        CountDownLatch countDownLatch = new CountDownLatch(dataList.size());</span><br><span class="line"></span><br><span class="line">        log(&quot;执行数据库操作&quot;);</span><br><span class="line">        String threadName = Thread.currentThread().getName();</span><br><span class="line">        //模拟插入数据</span><br><span class="line">        for (String s : dataList) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //模拟数据库操作耗时100毫秒</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">                    log(&quot;插入数据&quot; + s + &quot;成功,主线程：&quot; + threadName);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        //等待上面的dataList处理完毕</span><br><span class="line">        try &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //需要插入的数据</span><br><span class="line">        List&lt;String&gt; dataList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            dataList.add(&quot;数据&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //模拟5个请求</span><br><span class="line">        int requestCount = 5;</span><br><span class="line">        for (int i = 0; i &lt; requestCount; i++) &#123;</span><br><span class="line">            String traceId = String.valueOf(i);</span><br><span class="line">            disposeRequestExecutor.execute(() -&gt; &#123;</span><br><span class="line">                //把traceId放入口袋中</span><br><span class="line">                traceIdKD.set(traceId);</span><br><span class="line">                try &#123;</span><br><span class="line">                    controller(dataList);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    //将tranceId从口袋中移除</span><br><span class="line">                    traceIdKD.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        disposeRequestExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出中都有traceId了，和期望的结果一致。</p>
<h3 id="14-掌握JUC中的阻塞队列"><a href="#14-掌握JUC中的阻塞队列" class="headerlink" title="14. 掌握JUC中的阻塞队列"></a>14. 掌握JUC中的阻塞队列</h3><ol>
<li>掌握Queue、BlockingQueue接口中常用的方法</li>
<li>介绍6中阻塞队列，及相关场景示例</li>
<li>重点掌握4种常用的阻塞队列</li>
</ol>
<h4 id="1-Queue接口"><a href="#1-Queue接口" class="headerlink" title="1. Queue接口"></a>1. Queue接口</h4><p>队列是一种先进先出（FIFO）的数据结构，java中用<code>Queue</code>接口来表示队列。</p>
<p><code>Queue</code>接口中定义了6个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">    boolean add(e);</span><br><span class="line">    boolean offer(E e);</span><br><span class="line">    E remove();</span><br><span class="line">    E poll();</span><br><span class="line">    E element();</span><br><span class="line">    E peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>Queue</code>方法都有两种形式：</p>
<p>（1）如果操作失败则抛出异常，</p>
<p>（2）如果操作失败，则返回特殊值（<code>null</code>或<code>false</code>，具体取决于操作），接口的常规结构如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>抛出异常</strong></th>
<th><strong>返回特殊值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>检查（查看队首）</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><code>Queue</code>从<code>Collection</code>继承的<code>add</code>方法插入一个元素，除非它违反了队列的容量限制，在这种情况下它会抛出<code>IllegalStateException</code>；</p>
<p><code>offer</code>方法与<code>add</code>不同之处仅在于它通过返回<code>false</code>来表示插入元素失败。</p>
<p><code>remove</code>和<code>poll</code>方法都移除并返回队列的头部，确切地移除哪个元素是由具体的实现来决定的，仅当队列为空时，<code>remove</code>和<code>poll</code>方法的行为才有所不同，在这些情况下，<code>remove</code>抛出<code>NoSuchElementException</code>，而<code>poll</code>返回<code>null</code>。</p>
<p><code>element</code>和<code>peek</code>方法返回队列头部的元素，但不移除，它们之间的差异与<code>remove</code>和<code>poll</code>的方式完全相同，如果队列为空，则<code>element</code>抛出<code>NoSuchElementException</code>，而<code>peek</code>返回<code>null</code>。</p>
<p>队列一般不要插入空元素！！！</p>
<h4 id="2-BlockingQueue接口"><a href="#2-BlockingQueue接口" class="headerlink" title="2. BlockingQueue接口"></a>2. BlockingQueue接口</h4><p><code>BlockingQueue</code>位于juc中，称阻塞队列。</p>
<p> 阻塞队列首先它是一个队列，继承<code>Queue</code>接口，是队列就会遵循先进先出（FIFO）的原则，又因为它是阻塞的，故与普通的队列有两点区别：</p>
<ol>
<li>当一个线程向队列里面添加数据时，如果队列是满的，那么将阻塞该线程，暂停添加数据。</li>
<li>当一个线程从队列里面取出数据时，如果队列是空的，那么将阻塞该线程，暂停取出数据</li>
</ol>
<p><code>BlockingQueue</code>相关方法：</p>
<table>
<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>抛出异常</strong></th>
<th><strong>返回特殊值</strong></th>
<th><strong>一直阻塞</strong></th>
<th><strong>超时退出</strong></th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,timeuout,unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(timeout,unit)</td>
</tr>
<tr>
<td>检查（查看队首）</td>
<td>element()</td>
<td>peek()</td>
<td>不支持</td>
<td></td>
</tr>
</tbody></table>
<p><strong>重点，再来解释一下，加深印象：</strong></p>
<ol>
<li>3个可能会有异常的方法，add、remove、element；这3个方法不会阻塞（是说队列满或者空的情况下是否会阻塞）；队列满的情况下，add抛出异常；队列为空情况下，remove、element抛出异常</li>
<li>offer、poll、peek 也不会阻塞（是说队列满或者空的情况下是否会阻塞）；队列满的情况下，offer返回false；队列为空的情况下，pool、peek返回null</li>
<li><strong>队列满的情况下，调用put方法会导致当前线程阻塞</strong></li>
<li><strong>队列为空的情况下，调用take方法会导致当前线程阻塞</strong></li>
<li><code>offer(e,timeuout,unit)</code>，<strong>超时之前，插入成功返回true，否者返回false</strong></li>
<li><code>poll(timeout,unit)</code>，<strong>超时之前，获取到头部元素并将其移除，返回true，否者返回false</strong></li>
</ol>
<h4 id="3-BlockingQueue常见的实现类"><a href="#3-BlockingQueue常见的实现类" class="headerlink" title="3. BlockingQueue常见的实现类"></a>3. BlockingQueue常见的实现类</h4><p><strong>ArrayBlockingQueue</strong></p>
<blockquote>
<p>基于数组的阻塞队列实现，其内部维护一个定长的数组，用于存储队列元素。线程阻塞的实现是通过ReentrantLock来完成的，数据的插入与取出共用同一个锁，因此ArrayBlockingQueue并不能实现生产、消费同时进行。而且在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
</blockquote>
<p><strong>LinkedBlockingQueue</strong></p>
<blockquote>
<p>基于单向链表的阻塞队列实现，在初始化LinkedBlockingQueue的时候可以指定大小，也可以不指定，默认类似一个无限大小的容量（Integer.MAX_VALUE），不指队列容量大小也是会有风险的，一旦数据生产速度大于消费速度，系统内存将有可能被消耗殆尽，因此要谨慎操作。另外LinkedBlockingQueue中用于阻塞 生产者、消费者的锁是两个（锁分离），因此生产与消费是可以同时进行的。</p>
</blockquote>
<p><strong>PriorityBlockingQueue</strong></p>
<blockquote>
<p>一个支持优先级排序的无界阻塞队列，进入队列的元素会按照优先级进行排序</p>
</blockquote>
<p><strong>SynchronousQueue</strong></p>
<blockquote>
<p>同步阻塞队列，SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然</p>
</blockquote>
<p><strong>DelayQueue</strong></p>
<blockquote>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列，里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行，也就是说只有在延迟期到时才能够从队列中取元素</p>
</blockquote>
<p><strong>LinkedTransferQueue</strong></p>
<blockquote>
<p>LinkedTransferQueue是基于链表的FIFO无界阻塞队列，它出现在JDK7中，Doug Lea 大神说LinkedTransferQueue是一个聪明的队列，它是ConcurrentLinkedQueue、SynchronousQueue(公平模式下)、无界的LinkedBlockingQueues等的超集，<code>LinkedTransferQueue</code>包含了<code>ConcurrentLinkedQueue、SynchronousQueue、LinkedBlockingQueues</code>三种队列的功能</p>
</blockquote>
<h5 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1. ArrayBlockingQueue"></a>1. ArrayBlockingQueue</h5><p>有界阻塞队列，内部使用数组存储元素，有2个常用构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//capacity表示容量大小，默认内部采用非公平锁</span><br><span class="line">public ArrayBlockingQueue(int capacity)</span><br><span class="line"></span><br><span class="line">//capacity：容量大小，fair：内部是否是使用公平锁public ArrayBlockingQueue(int capacity, boolean fair)</span><br></pre></td></tr></table></figure>



<p><strong>需求：</strong>业务系统中有很多地方需要推送通知，由于需要推送的数据太多，我们将需要推送的信息先丢到阻塞队列中，然后开一个线程进行处理真实发送，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import sun.text.normalizer.NormalizerBase;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    //推送队列</span><br><span class="line">    static ArrayBlockingQueue&lt;String&gt; pushQueue = new ArrayBlockingQueue&lt;String&gt;(10000);</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //启动一个线程做真实推送</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                String msg;</span><br><span class="line">                try &#123;</span><br><span class="line">                    long starTime = System.currentTimeMillis();</span><br><span class="line">                    //获取一条推送消息，此方法会进行阻塞，直到返回结果</span><br><span class="line">                    msg = pushQueue.take();</span><br><span class="line">                    long endTime = System.currentTimeMillis();</span><br><span class="line">                    //模拟推送耗时</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line"></span><br><span class="line">                    System.out.println(String.format(&quot;[%s,%s,take耗时:%s],%s,发送消息:%s&quot;, starTime, endTime, (endTime - starTime), Thread.currentThread().getName(), msg));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //推送消息，需要发送推送消息的调用该方法，会将推送信息先加入推送队列</span><br><span class="line">    public static void pushMsg(String msg) throws InterruptedException &#123;</span><br><span class="line">        pushQueue.put(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            String msg = &quot;一起来学java高并发,第&quot; + i + &quot;天&quot;;</span><br><span class="line">            //模拟耗时</span><br><span class="line">            TimeUnit.SECONDS.sleep(i);</span><br><span class="line">            Demo1.pushMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中我们使用了有界队列<code>ArrayBlockingQueue</code>，创建<code>ArrayBlockingQueue</code>时候需要制定容量大小，调用<code>pushQueue.put</code>将推送信息放入队列中，如果队列已满，此方法会阻塞。代码中在静态块中启动了一个线程，调用<code>pushQueue.take();</code>从队列中获取待推送的信息进行推送处理。</p>
<p><strong>注意：</strong><code>ArrayBlockingQueue</code>如果队列容量设置的太小，消费者发送的太快，消费者消费的太慢的情况下，会导致队列空间满，调用put方法会导致发送者线程阻塞，所以注意设置合理的大小，协调好消费者的速度。</p>
<h5 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2. LinkedBlockingQueue"></a>2. LinkedBlockingQueue</h5><p><code>LinkedBlockingQueue</code>的用法和<code>ArrayBlockingQueue</code>类似，建议使用的时候指定容量，如果不指定容量，插入的太快，移除的太慢，可能会产生OOM。</p>
<h5 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3. PriorityBlockingQueue"></a>3. PriorityBlockingQueue</h5><p><strong>无界的优先级</strong>阻塞队列，内部使用数组存储数据，达到容量时，会自动进行扩容，放入的元素会按照优先级进行排序，4个构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//默认构造方法，默认初始化容量是11</span><br><span class="line">public PriorityBlockingQueue();</span><br><span class="line"></span><br><span class="line">//指定队列的初始化容量</span><br><span class="line">public PriorityBlockingQueue(int initialCapacity);</span><br><span class="line"></span><br><span class="line">//指定队列的初始化容量和放入元素的比较器</span><br><span class="line">public PriorityBlockingQueue(int initialCapacity,Comparator&lt;? super E&gt; comparator);</span><br><span class="line"></span><br><span class="line">//传入集合放入来初始化队列，传入的集合可以实现SortedSet接口或者PriorityQueue接口进行排序，</span><br><span class="line">//如果没有实现这2个接口，按正常顺序放入队列</span><br><span class="line">public PriorityBlockingQueue(Collection&lt;? extends E&gt; c);</span><br></pre></td></tr></table></figure>

<p>优先级队列放入元素的时候，会进行排序，所以我们需要指定排序规则，有2种方式：</p>
<ol>
<li>创建<code>PriorityBlockingQueue</code>指定比较器<code>Comparator</code></li>
<li>放入的元素需要实现<code>Comparable</code>接口</li>
</ol>
<p>上面2种方式必须选一个，如果2个都有，则走第一个规则排序。</p>
<p><strong>需求：</strong>还是上面的推送业务，目前推送是按照放入的先后顺序进行发送的，比如有些公告比较紧急，优先级比较高，需要快点发送，怎么搞？此时<code>PriorityBlockingQueue</code>就派上用场了，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    //推送信息封装</span><br><span class="line">    static class Msg implements Comparable&lt;Msg&gt; &#123;</span><br><span class="line">        //优先级，越小优先级越高</span><br><span class="line">        private int priority;</span><br><span class="line">        //推送的信息</span><br><span class="line">        private String msg;</span><br><span class="line"></span><br><span class="line">        public Msg(int priority, String msg) &#123;</span><br><span class="line">            this.priority = priority;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compareTo(Msg o) &#123;</span><br><span class="line">            return Integer.compare(this.priority, o.priority);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Msg&#123;&quot; +</span><br><span class="line">                    &quot;priority=&quot; + priority +</span><br><span class="line">                    &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //推送队列</span><br><span class="line">    static PriorityBlockingQueue&lt;Msg&gt; pushQueue = new PriorityBlockingQueue&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //启动一个线程做真实推送</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Msg msg;</span><br><span class="line">                try &#123;</span><br><span class="line">                    long starTime = System.currentTimeMillis();</span><br><span class="line">                    //获取一条推送消息，此方法会进行阻塞，直到返回结果</span><br><span class="line">                    msg = pushQueue.take();</span><br><span class="line">                    //模拟推送耗时</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">                    long endTime = System.currentTimeMillis();</span><br><span class="line">                    System.out.println(String.format(&quot;[%s,%s,take耗时:%s],%s,发送消息:%s&quot;, starTime, endTime, (endTime - starTime), Thread.currentThread().getName(), msg));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //推送消息，需要发送推送消息的调用该方法，会将推送信息先加入推送队列</span><br><span class="line">    public static void pushMsg(int priority, String msg) throws InterruptedException &#123;</span><br><span class="line">        pushQueue.put(new Msg(priority, msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 5; i &gt;= 1; i--) &#123;</span><br><span class="line">            String msg = &quot;一起来学java高并发,第&quot; + i + &quot;天&quot;;</span><br><span class="line">            Demo2.pushMsg(i, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main中放入了5条推送信息，i作为消息的优先级按倒叙放入的，最终输出结果中按照优先级由小到大输出。注意Msg实现了<code>Comparable</code>接口，具有了比较功能。[比较器默认从小到大排序]</p>
<h5 id="4-SynchronousQueue"><a href="#4-SynchronousQueue" class="headerlink" title="4. SynchronousQueue"></a>4. SynchronousQueue</h5><blockquote>
<p>同步阻塞队列，SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。SynchronousQueue 在现实中用的不多，线程池中有用到过，<code>Executors.newCachedThreadPool()</code>实现中用到了这个队列，当有任务丢入线程池的时候，如果已创建的工作线程都在忙于处理任务，则会新建一个线程来处理丢入队列的任务。</p>
</blockquote>
<p>来个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line">import java.util.concurrent.SynchronousQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line"></span><br><span class="line">    static SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                long starTime = System.currentTimeMillis();</span><br><span class="line">                queue.put(&quot;java高并发系列，路人甲Java!&quot;);</span><br><span class="line">                long endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(String.format(&quot;[%s,%s,take耗时:%s],%s&quot;, starTime, endTime, (endTime - starTime), Thread.currentThread().getName()));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        //休眠5秒之后，从队列中take一个元素</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        System.out.println(System.currentTimeMillis() + &quot;调用take获取并移除元素,&quot; + queue.take());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法中启动了一个线程，调用<code>queue.put</code>方法向队列中丢入一条数据，调用的时候产生了阻塞，从输出结果中可以看出，直到take方法被调用时，put方法才从阻塞状态恢复正常。即put 被阻塞，直至 take 方法被调用。</p>
<h5 id="5-DelayQueue"><a href="#5-DelayQueue" class="headerlink" title="5. DelayQueue"></a>5. DelayQueue</h5><blockquote>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列，里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行，也就是说只有在延迟期到时才能够从队列中取元素。</p>
</blockquote>
<p><strong>需求：</strong>还是推送的业务，有时候我们希望早上9点或者其他指定的时间进行推送，如何实现呢？此时<code>DelayQueue</code>就派上用场了。</p>
<p>我们先看一下<code>DelayQueue</code>类的声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;    implements BlockingQueue&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>元素E需要实现接口<code>Delayed</code>，我们看一下这个接口的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Delayed extends Comparable&lt;Delayed&gt; &#123;    </span><br><span class="line">long getDelay(TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Delayed</code>继承了<code>Comparable</code>接口，这个接口是用来做比较用的，<code>DelayQueue</code>内部使用<code>PriorityQueue</code>来存储数据的，<code>PriorityQueue</code>是一个优先级队列，丢入的数据会进行排序，排序方法调用的是<code>Comparable</code>接口中的方法。</p>
<p>下面主要说一下<code>Delayed</code>接口中的<code>getDelay</code>方法：此方法在给定的时间单位内返回与此对象关联的剩余延迟时间。</p>
<p><strong>对推送我们再做一下处理，让其支持定时发送（定时在将来某个时间也可以说是延迟发送），代码如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.concurrent.DelayQueue;</span><br><span class="line">import java.util.concurrent.Delayed;</span><br><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">public class Demo4 &#123;</span><br><span class="line"></span><br><span class="line">    //推送信息封装</span><br><span class="line">    static class Msg implements Delayed &#123;</span><br><span class="line">        //优先级，越小优先级越高</span><br><span class="line">        private int priority;</span><br><span class="line">        //推送的信息</span><br><span class="line">        private String msg;</span><br><span class="line">        //定时发送时间，毫秒格式</span><br><span class="line">        private long sendTimeMs;</span><br><span class="line"></span><br><span class="line">        public Msg(int priority, String msg, long sendTimeMs) &#123;</span><br><span class="line">            this.priority = priority;</span><br><span class="line">            this.msg = msg;</span><br><span class="line">            this.sendTimeMs = sendTimeMs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Msg&#123;&quot; +</span><br><span class="line">                    &quot;priority=&quot; + priority +</span><br><span class="line">                    &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                    &quot;, sendTimeMs=&quot; + sendTimeMs +</span><br><span class="line">                    &#x27;&#125;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public long getDelay(TimeUnit unit) &#123;</span><br><span class="line">            return unit.convert(this.sendTimeMs - Calendar.getInstance().getTimeInMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compareTo(Delayed o) &#123;</span><br><span class="line">            if (o instanceof Msg) &#123;</span><br><span class="line">                Msg c2 = (Msg) o;</span><br><span class="line">                return Integer.compare(this.priority, c2.priority);</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //推送队列</span><br><span class="line">    static DelayQueue&lt;Msg&gt; pushQueue = new DelayQueue&lt;Msg&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //启动一个线程做真实推送</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Msg msg;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //获取一条推送消息，此方法会进行阻塞，直到返回结果</span><br><span class="line">                    msg = pushQueue.take();</span><br><span class="line">                    //此处可以做真实推送</span><br><span class="line">                    long endTime = System.currentTimeMillis();</span><br><span class="line">                    System.out.println(String.format(&quot;定时发送时间：%s,实际发送时间：%s,发送消息:%s&quot;, msg.sendTimeMs, endTime, msg));</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //推送消息，需要发送推送消息的调用该方法，会将推送信息先加入推送队列</span><br><span class="line">    public static void pushMsg(int priority, String msg, long sendTimeMs) throws InterruptedException &#123;</span><br><span class="line">        pushQueue.put(new Msg(priority, msg, sendTimeMs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i = 5; i &gt;= 1; i--) &#123;</span><br><span class="line">            String msg = &quot;一起来学java高并发,第&quot; + i + &quot;天&quot;;</span><br><span class="line">            Demo4.pushMsg(i, msg, Calendar.getInstance().getTimeInMillis() + i * 2000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出发送时间，和定时发送时间基本一致，代码中<code>Msg</code>需要实现<code>Delayed接口</code>，重点在于<code>getDelay</code>方法，这个方法返回剩余的延迟时间，代码中使用<code>this.sendTimeMs</code>减去当前时间的毫秒格式时间，得到剩余延迟时间。</p>
<h5 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h5><blockquote>
<p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p>
</blockquote>
<p>LinkedTransferQueue类继承自AbstractQueue抽象类，并且实现了TransferQueue接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface TransferQueue&lt;E&gt; extends BlockingQueue&lt;E&gt; &#123;    </span><br><span class="line"></span><br><span class="line">// 如果存在一个消费者已经等待接收它，则立即传送指定的元素，否则返回false，并且不进入队列。    boolean tryTransfer(E e);    </span><br><span class="line"></span><br><span class="line">// 如果存在一个消费者已经等待接收它，则立即传送指定的元素，否则等待直到元素被消费者接收。    void transfer(E e) throws InterruptedException;    </span><br><span class="line"></span><br><span class="line">// 在上述方法的基础上设置超时时间    </span><br><span class="line">boolean tryTransfer(E e,long timeout,TimeUnit unit) throws InterruptedException; </span><br><span class="line"></span><br><span class="line">// 如果至少有一位消费者在等待，则返回true    </span><br><span class="line">boolean hasWaitingConsumer();    </span><br><span class="line"></span><br><span class="line">// 获取所有等待获取元素的消费线程数量    </span><br><span class="line">int getWaitingConsumerCount();&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下上面的这些方法，<code>transfer(E e)</code>方法和<code>SynchronousQueue的put方法</code>类似，都需要等待消费者取走元素，否者一直等待。其他方法和<code>ArrayBlockingQueue、LinkedBlockingQueue</code>中的方法类似。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>重点需要了解<code>BlockingQueue</code>中的所有方法，以及他们的区别</li>
<li>重点掌握<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code>、<code>DelayQueue</code>的使用场景</li>
<li>需要处理的任务有优先级的，使用<code>PriorityBlockingQueue</code></li>
<li>处理的任务需要延时处理的，使用<code>DelayQueue</code></li>
</ol>
<h1 id="3-Java-高并发实战篇"><a href="#3-Java-高并发实战篇" class="headerlink" title="3. Java 高并发实战篇"></a>3. Java 高并发实战篇</h1><h2 id="1-接口性能提升几倍原来这么简单"><a href="#1-接口性能提升几倍原来这么简单" class="headerlink" title="1. 接口性能提升几倍原来这么简单"></a>1. 接口性能提升几倍原来这么简单</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933201&amp;idx=1&amp;sn=b21aeda79e6e6a825826f08fef14f09e&amp;chksm=88621b6fbf159279a2d9e3f195e1be888a9e20cdf95a637385fbd69b5e4be1a99c193da5a611&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933201&amp;idx=1&amp;sn=b21aeda79e6e6a825826f08fef14f09e&amp;chksm=88621b6fbf159279a2d9e3f195e1be888a9e20cdf95a637385fbd69b5e4be1a99c193da5a611&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<h2 id="2-高并发中常见的限流方式"><a href="#2-高并发中常见的限流方式" class="headerlink" title="2. 高并发中常见的限流方式"></a>2. 高并发中常见的限流方式</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933212&amp;idx=1&amp;sn=b1e8f65d4673bd3cf64c2d6a00645ba9&amp;chksm=88621b62bf15927422958029a1d240198082104d6e50d15dd33c5d3cf5af2195050b772782ec&amp;scene=178&amp;cur_album_id=1318984626890915841#rd">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933212&amp;idx=1&amp;sn=b1e8f65d4673bd3cf64c2d6a00645ba9&amp;chksm=88621b62bf15927422958029a1d240198082104d6e50d15dd33c5d3cf5af2195050b772782ec&amp;scene=178&amp;cur_album_id=1318984626890915841#rd</a></p>
<h2 id="3-获取线程执行结果的六种方法"><a href="#3-获取线程执行结果的六种方法" class="headerlink" title="3. 获取线程执行结果的六种方法"></a>3. 获取线程执行结果的六种方法</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933226&amp;idx=1&amp;sn=08460a77d15806d094eb9b9af254c8ee&amp;chksm=88621b54bf1592424d209dac77da11ded524807ab76567c326772a113229c78fe2ddb162a599&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933226&amp;idx=1&amp;sn=08460a77d15806d094eb9b9af254c8ee&amp;chksm=88621b54bf1592424d209dac77da11ded524807ab76567c326772a113229c78fe2ddb162a599&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect</a></p>
<h2 id="4-高并发中计数器的实现方式有哪些？"><a href="#4-高并发中计数器的实现方式有哪些？" class="headerlink" title="4. 高并发中计数器的实现方式有哪些？"></a>4. 高并发中计数器的实现方式有哪些？</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933231&amp;idx=1&amp;sn=627a3e9ba24822e05d1151f4206c0416&amp;chksm=88621b51bf15924798bffd960993207aae67f8f08843308b3d54808bc3d85c5dcfa673d69666&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933231&amp;idx=1&amp;sn=627a3e9ba24822e05d1151f4206c0416&amp;chksm=88621b51bf15924798bffd960993207aae67f8f08843308b3d54808bc3d85c5dcfa673d69666&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect</a></p>
<h2 id="5-怎么演示公平锁和非公平锁"><a href="#5-怎么演示公平锁和非公平锁" class="headerlink" title="5. 怎么演示公平锁和非公平锁?"></a>5. 怎么演示公平锁和非公平锁?</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933275&amp;idx=1&amp;sn=7cb4c836ab6a6b94d9c971a5beebdb59&amp;chksm=88621ba5bf1592b3b902a965012e399472dd21847af992fd0da8cd22a5cc448084f04e067f92&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933275&amp;idx=1&amp;sn=7cb4c836ab6a6b94d9c971a5beebdb59&amp;chksm=88621ba5bf1592b3b902a965012e399472dd21847af992fd0da8cd22a5cc448084f04e067f92&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect</a></p>
<h2 id="6-google提供的一些好用的并发工具类"><a href="#6-google提供的一些好用的并发工具类" class="headerlink" title="6. google提供的一些好用的并发工具类"></a>6. google提供的一些好用的并发工具类</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933285&amp;idx=1&amp;sn=f5507c251b84c3405f2fe0f7fb1da97d&amp;chksm=88621b9bbf15928dd4c26f52b2abb0e130cde02100c432f33f0e90123b5e4b20d43017c1030e&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzA5MTkxMDQ4MQ==&amp;mid=2648933285&amp;idx=1&amp;sn=f5507c251b84c3405f2fe0f7fb1da97d&amp;chksm=88621b9bbf15928dd4c26f52b2abb0e130cde02100c432f33f0e90123b5e4b20d43017c1030e&amp;cur_album_id=1318984626890915841&amp;scene=189#wechat_redirect</a></p>

    </div>

    <div></div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-java-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">1. java 高并发基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%EF%BC%88Synchronous%EF%BC%89%E5%92%8C%E5%BC%82%E6%AD%A5%EF%BC%88Asynchronous%EF%BC%89"><span class="toc-text">1. 同步（Synchronous）和异步（Asynchronous）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%EF%BC%88Concurrency%EF%BC%89%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%88Parallelism%EF%BC%89"><span class="toc-text">2. 并发（Concurrency）和并行（Parallelism）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">3. 临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%BB%E5%A1%9E%EF%BC%88Blocking%EF%BC%89%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88Non-Blocking%EF%BC%89"><span class="toc-text">4. 阻塞（Blocking）和非阻塞（Non-Blocking）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81%EF%BC%88Deadlock%EF%BC%89%E3%80%81%E9%A5%A5%E9%A5%BF%EF%BC%88Starvation%EF%BC%89%E5%92%8C%E6%B4%BB%E9%94%81%EF%BC%88Livelock%EF%BC%89"><span class="toc-text">5. 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%BB%E9%94%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">1. 死锁举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A5%A5%E9%A5%BF%E4%B8%BE%E4%BE%8B"><span class="toc-text">2. 饥饿举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E7%BA%A7%E5%88%AB"><span class="toc-text">2. 并发级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%BB%E5%A1%9E"><span class="toc-text">1. 阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E9%A5%A5%E9%A5%BF-Starvation-Free"><span class="toc-text">2. 无饥饿(Starvation-Free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%97%A0%E9%9A%9C%E7%A2%8D-Obstruction-Free"><span class="toc-text">3. 无障碍(Obstruction-Free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%A0%E9%94%81-Lock-Free"><span class="toc-text">4. 无锁(Lock-Free)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%A0%E7%AD%89%E5%BE%85"><span class="toc-text">5. 无等待</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9C%89%E5%85%B3%E5%B9%B6%E8%A1%8C%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%87%8D%E8%A6%81%E5%AE%9A%E5%BE%8B"><span class="toc-text">3. 有关并行的两个重要定律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Amdahl-%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94-%E5%AE%9A%E5%BE%8B"><span class="toc-text">1. Amdahl(阿姆达尔)定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Gustafson%E5%AE%9A%E5%BE%8B"><span class="toc-text">2. Gustafson定律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JMM%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-text">4. JMM相关的一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">1. 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">2. 可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">3. 有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">5. 深入理解进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">1. 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">6. 线程的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. 新建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 终止线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-text">3. 线程中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%80%E4%B8%AA%E4%BE%BF%E4%BA%8E%E7%90%86%E8%A7%A3%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">1. 一个便于理解的例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%AD%89%E5%BE%85%EF%BC%88wait%EF%BC%89%E5%92%8C%E9%80%9A%E7%9F%A5%EF%BC%88notify%EF%BC%89"><span class="toc-text">4. 等待（wait）和通知（notify）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%EF%BC%88join%EF%BC%89%E5%92%8C%E8%B0%A6%E8%AE%A9%EF%BC%88yeild%EF%BC%89"><span class="toc-text">5. 等待线程结束（join）和谦让（yeild）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-volatile%E4%B8%8EJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">7. volatile与Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-text">8. 线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-text">1. 线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%85%B3%E8%81%94%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-text">1. 创建线程关联线程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E7%BA%BF%E7%A8%8B%E7%BB%84%E6%8C%87%E5%AE%9A%E7%88%B6%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-text">2. 为线程组指定父线程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B9%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-text">3. 根线程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%B9%E9%87%8F%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">4. 批量停止线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">9. 用户线程和守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-text">1. 守护线程的一些特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">10. 线程安全和synchronized关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1. 什么是线程安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-synchronized%E4%B8%BB%E8%A6%81%E6%9C%893%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">2. synchronized主要有3种使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-synchronized%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. synchronized作用于实例对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-synchronized%E4%BD%9C%E7%94%A8%E4%BA%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">2. synchronized作用于静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-synchronized%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">3. synchronized同步代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">11. 线程中断的几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD"><span class="toc-text">1. 通过一个变量控制线程中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E8%87%AA%E5%B8%A6%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 通过线程自带的中断标志控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E4%B8%AD%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-text">3. 线程阻塞状态中如何中断？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Java-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%8F%90%E9%AB%98%E7%AF%87"><span class="toc-text">2. Java 高并发提高篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JUC%E9%83%A8%E5%88%86"><span class="toc-text">1. JUC部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">1. ReentrantLock重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-synchronized%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">1. synchronized的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReentrantLock"><span class="toc-text">2. ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ReentrantLock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1. ReentrantLock基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-synchronized%E6%96%B9%E5%BC%8F"><span class="toc-text">1. synchronized方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-ReentrantLock%E6%96%B9%E5%BC%8F"><span class="toc-text">2. ReentrantLock方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ReentrantLock%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">3. ReentrantLock是可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ReentrantLock%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">4. ReentrantLock实现公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ReentrantLock%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84"><span class="toc-text">5. ReentrantLock获取锁的过程是可中断的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ReentrantLock%E9%94%81%E7%94%B3%E8%AF%B7%E7%AD%89%E5%BE%85%E9%99%90%E6%97%B6"><span class="toc-text">6.ReentrantLock锁申请等待限时</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-tryLock-%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95"><span class="toc-text">1. tryLock() 无参方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-tryLock-%E6%9C%89%E5%8F%82%E6%96%B9%E6%B3%95"><span class="toc-text">2. tryLock() 有参方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-ReentrantLock%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">7. ReentrantLock其他常用的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="toc-text">8. 获取锁的4种方法对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JUC%E4%B8%AD%E7%9A%84Condition%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. JUC中的Condition对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-synchronized%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-text">1. synchronized中实现线程等待和唤醒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Condition%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. Condition简介及常用方法介绍及相关示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Condition常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Condition-await-%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%A2%AB%E6%89%93%E6%96%AD"><span class="toc-text">Condition.await()过程中被打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await-long-time-TimeUnit-unit-%E8%B6%85%E6%97%B6%E4%B9%8B%E5%90%8E%E8%87%AA%E5%8A%A8%E8%BF%94%E5%9B%9E"><span class="toc-text">await(long time, TimeUnit unit)超时之后自动返回</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await-long-time-TimeUnit-unit-%E8%B6%85%E6%97%B6%E4%B9%8B%E5%89%8D%E8%A2%AB%E5%94%A4%E9%86%92"><span class="toc-text">await(long time, TimeUnit unit)超时之前被唤醒</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8Condition%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">3. 使用Condition实现同步阻塞队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JUC%E4%B8%AD%E7%9A%84LockSupport%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8C%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD"><span class="toc-text">3. JUC中的LockSupport工具类，必备技能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-text">1. 线程等待与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-text">1.使用Object类中的方法实现线程等待和唤醒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8Condition%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92"><span class="toc-text">2. 使用Condition实现线程的等待和唤醒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Object%E5%92%8CCondition%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">3. Object和Condition的局限性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-LockSupport%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-text">2. LockSupport类介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JUC%E4%B8%AD%E7%9A%84Semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="toc-text">4. JUC中的Semaphore（信号量）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Semaphore%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">1. Semaphore主要方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B1%EF%BC%9ASemaphore%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 示例1：Semaphore简单的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%90%8E%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%B9%B6%E6%AD%A3%E7%A1%AE%E9%87%8A%E6%94%BE"><span class="toc-text">2. 示例2：获取不到后，中断并正确释放</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">其他一些使用说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JUC%E4%B8%AD%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BBCountDownLatch%EF%BC%8C%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD"><span class="toc-text">5. JUC中等待多线程完成的工具类CountDownLatch，必备技能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CountDownLatch%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. CountDownLatch介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例1：一个简单的示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E7%AD%89%E5%BE%85%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4"><span class="toc-text">示例2：等待指定时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9A2%E4%B8%AACountDown%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例3：2个CountDown结合使用的示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">2. 手写一个并行处理任务的工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JUC%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%B1%8F%E9%9A%9CCyclicBarrier%E7%9A%846%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">6. JUC中的循环屏障CyclicBarrier的6种使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CyclicBarrier%E7%AE%80%E4%BB%8B"><span class="toc-text">1. CyclicBarrier简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8CyclicBarrier"><span class="toc-text">1. 示例1：简单使用CyclicBarrier</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8CyclicBarrier"><span class="toc-text">2. 示例2：重复使用CyclicBarrier</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B3%EF%BC%9A-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">3. 示例3： 最后一个线程，需要额外的操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B4%EF%BC%9A%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%AD%E8%A2%AB%E6%89%93%E6%96%AD%E4%BA%86"><span class="toc-text">4. 示例4：其中一个线程等待中被打断了</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CountDownLatch%E5%92%8CCyclicBarrier%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">2. CountDownLatch和CyclicBarrier的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">7. JAVA线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">1. 什么是线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">2. 线程池实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3. java中的线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 线程池使用的简单示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text">5. 线程池中常见的工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SynchronousQueue%E9%98%9F%E5%88%97%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">SynchronousQueue队列的线程池</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PriorityBlockingQueue%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">PriorityBlockingQueue优先级队列的线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E5%B7%A5%E5%8E%82"><span class="toc-text">6. 自定义线程创建的工厂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-text">7. 常见的饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-text">8. 自定义饱和策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%B8%A4%E7%A7%8D%E5%85%B3%E9%97%AD%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-text">9. 线程池中两种关闭方法有何不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E6%89%A9%E5%B1%95%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">10. 扩展线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%90%88%E7%90%86%E5%9C%B0%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">11. 合理地配置线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">12. 线程池中线程数量的配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-text">一些使用建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JUC%E4%B8%AD%E7%9A%84Executor%E6%A1%86%E6%9E%B61"><span class="toc-text">8. JUC中的Executor框架1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Executors%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-text">1. Executors框架介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Executor%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. Executor接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-ExecutorService%E6%8E%A5%E5%8F%A3"><span class="toc-text">3. ExecutorService接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-ThreadPoolExecutor%E7%B1%BB"><span class="toc-text">4. ThreadPoolExecutor类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ScheduleThreadPoolExecutor%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">5. ScheduleThreadPoolExecutor定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#schedule-%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A11%E6%AC%A1"><span class="toc-text">schedule:延迟执行任务1次</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#scheduleAtFixedRate-%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%A2%91%E7%8E%87%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">scheduleAtFixedRate:固定的频率执行任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#scheduleWithFixedDelay-%E5%9B%BA%E5%AE%9A%E7%9A%84%E9%97%B4%E9%9A%94%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-text">scheduleWithFixedDelay:固定的间隔执行任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-text">定时任务有异常会怎么样？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-text">取消定时任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Executors%E7%B1%BB"><span class="toc-text">6. Executors类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#newScheduledThreadPool"><span class="toc-text">newScheduledThreadPool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Future%E3%80%81Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">7. Future、Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">获取异步任务执行结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E8%8E%B7%E5%8F%96%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">超时获取异步任务执行结果</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-FutureTask%E7%B1%BB"><span class="toc-text">8. FutureTask类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-JUC%E4%B8%AD%E7%9A%84Executor%E6%A1%86%E6%9E%B62"><span class="toc-text">9. JUC中的Executor框架2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Java%E4%B8%AD%E7%9A%84CAS"><span class="toc-text">10. Java中的CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-JUC%E5%BA%95%E5%B1%82%E5%B7%A5%E5%85%B7%E7%B1%BBUnsafe%EF%BC%8C%E9%AB%98%E6%89%8B%E5%BF%85%E9%A1%BB%E8%A6%81%E4%BA%86%E8%A7%A3"><span class="toc-text">11. JUC底层工具类Unsafe，高手必须要了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-JUC%E4%B8%AD%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">12. JUC中原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-ThreadLocal%E3%80%81InheritableThreadLocal%EF%BC%88%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%EF%BC%89"><span class="toc-text">13. ThreadLocal、InheritableThreadLocal（通俗易懂）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1. 需要解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8DThreadLocal"><span class="toc-text">2. 介绍ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8DInheritableThreadLocal"><span class="toc-text">3. 介绍InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%8E%8C%E6%8F%A1JUC%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-text">14. 掌握JUC中的阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Queue%E6%8E%A5%E5%8F%A3"><span class="toc-text">1. Queue接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-BlockingQueue%E6%8E%A5%E5%8F%A3"><span class="toc-text">2. BlockingQueue接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-BlockingQueue%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">3. BlockingQueue常见的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayBlockingQueue"><span class="toc-text">1. ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedBlockingQueue"><span class="toc-text">2. LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-PriorityBlockingQueue"><span class="toc-text">3. PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-SynchronousQueue"><span class="toc-text">4. SynchronousQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-DelayQueue"><span class="toc-text">5. DelayQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-LinkedTransferQueue"><span class="toc-text">6. LinkedTransferQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Java-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%AE%9E%E6%88%98%E7%AF%87"><span class="toc-text">3. Java 高并发实战篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%87%A0%E5%80%8D%E5%8E%9F%E6%9D%A5%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95"><span class="toc-text">1. 接口性能提升几倍原来这么简单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 高并发中常见的限流方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">3. 获取线程执行结果的六种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%AD%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">4. 高并发中计数器的实现方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%80%8E%E4%B9%88%E6%BC%94%E7%A4%BA%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">5. 怎么演示公平锁和非公平锁?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-google%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">6. google提供的一些好用的并发工具类</span></a></li></ol></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>
<div class="share" style="width: 100%;">
  <img src="/../../../../images/wechat.png" alt="Running Geek" style="margin: auto; display: block;"/>

  <div style="margin: auto; text-align: center; font-size: 0.8em; color: grey;">微信扫一扫向我投食</div>
  
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/05/12/Java/java%E7%AC%94%E8%AE%B0/" rel="next" title="Java 笔记">
          Java 笔记
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" target="_blank" rel="noopener" href="https://zshlovely.github.io/">首页</a> |
        <a class="bottom-item" href="https://zshlovely.github.io/" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/fenghuayangyi" target="_blank">GitHub</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
